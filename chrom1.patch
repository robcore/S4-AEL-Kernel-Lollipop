CHROMIUM: mm: Fix calculation of dirtyable memory

The system uses global_dirtyable_memory() to calculate
number of dirtyable pages/pages that can be allocated
to the page cache.  A bug causes an underflow thus making
the page count look like a big unsigned number.  This in turn
confuses the dirty writeback throttling to aggressively write
back pages as they become dirty (usually 1 page at a time).

Fix is to check for underflow using signed arithmetic.

Signed-off-by: Sonny Rao <sonnyrao@chromium.org>
Signed-off-by: Puneet Kumar <puneetster@chromium.org>

BUG=chrome-os-partner:16011
TEST=Manual; boot kernel, powerwash, login with testaccount and
make sure no jank occurs on sync of applications

Change-Id: I614e7c3156e014f0f28a4ef9bdd8cb8a2cd07b2a

diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 26adea8..84e51ac 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c

@@ -35,6 +35,7 @@
 #include <linux/buffer_head.h> /* __set_page_dirty_buffers */
 #include <linux/pagevec.h>
 #include <trace/events/writeback.h>
+#include <linux/ratelimit.h>
 
 /*
  * Sleep at most 200ms at a time in balance_dirty_pages().
@@ -180,11 +181,14 @@
 	unsigned long x = 0;
 
 	for_each_node_state(node, N_HIGH_MEMORY) {
+		long fpages = 0;
 		struct zone *z =
 			&NODE_DATA(node)->node_zones[ZONE_HIGHMEM];
 
-		x += zone_page_state(z, NR_FREE_PAGES) +
-		     zone_reclaimable_pages(z) - z->dirty_balance_reserve;
+		fpages = zone_page_state(z, NR_FREE_PAGES) +
+			zone_reclaimable_pages(z) - z->dirty_balance_reserve;
+		if (fpages > 0)
+			x += fpages;
 	}
 	/*
 	 * Make sure that the number of highmem pages is never larger
@@ -206,13 +210,18 @@
  */
 unsigned long global_dirtyable_memory(void)
 {
-	unsigned long x;
+	unsigned long x = 0;
+	long fpages;
 
-	x = global_page_state(NR_FREE_PAGES) + global_reclaimable_pages() -
-	    dirty_balance_reserve;
+
+	fpages = global_page_state(NR_FREE_PAGES) + global_reclaimable_pages() -
+		dirty_balance_reserve;
 
 	if (!vm_highmem_is_dirtyable)
-		x -= highmem_dirtyable_memory(x);
+		fpages -= highmem_dirtyable_memory(x);
+
+	if (fpages > 0)
+		x = fpages;
 
 	return x + 1;	/* Ensure that we never return 0 */
 }
