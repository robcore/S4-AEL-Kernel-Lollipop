From 8cd504478ecd52634eb3778a63ba34634717c4c8 Mon Sep 17 00:00:00 2001
From: Steve Kondik <shade@chemlab.org>
Date: Tue, 14 May 2013 14:42:57 -0700
Subject: [PATCH] drivers: staging: Fix Zcache

 * Remove dependency on obsolete qcache
 * Remove X86 dependency as this version of zsmalloc supports ARM
 * Fix args for updated zsmalloc
 * Enable for JF

Change-Id: I7a6daf84246df54bb8030268d07a96256db4fc42

Conflicts:
	arch/arm/configs/cyanogen_jf_defconfig
---
 arch/arm/mach-msm/Kconfig            |  2 --
 drivers/gpu/ion/msm/msm_ion.c        |  2 +-
 drivers/staging/zcache/Kconfig       |  3 +--
 drivers/staging/zcache/zcache-main.c | 16 ++++++++--------
 4 files changed, 10 insertions(+), 13 deletions(-)

diff --git a/arch/arm/mach-msm/Kconfig b/arch/arm/mach-msm/Kconfig
index 40ec41e..0c19504 100644
--- a/arch/arm/mach-msm/Kconfig
+++ b/arch/arm/mach-msm/Kconfig
@@ -162,7 +162,6 @@ config ARCH_MSM8960
 	select ARCH_SPARSEMEM_ENABLE
 	select ARCH_HAS_HOLES_MEMORYMODEL
 	select CLEANCACHE
-	select QCACHE
 	select MSM_MULTIMEDIA_USE_ION
 	select MULTI_IRQ_HANDLER
 	select MSM_PM8X60 if PM
@@ -228,7 +227,6 @@ config ARCH_APQ8064
 	select CPU_HAS_L2_PMU
 	select HOLES_IN_ZONE if SPARSEMEM
 	select CLEANCACHE
-	select QCACHE
 	select MIGHT_HAVE_PCI
 	select ARCH_SUPPORTS_MSI
 	select ARM_HAS_SG_CHAIN
diff --git a/drivers/gpu/ion/msm/msm_ion.c b/drivers/gpu/ion/msm/msm_ion.c
index 46826b1..e8e4acd 100644
--- a/drivers/gpu/ion/msm/msm_ion.c
+++ b/drivers/gpu/ion/msm/msm_ion.c
@@ -218,7 +218,7 @@ static void allocate_co_memory(struct ion_platform_heap *heap,
 		if (shared_heap) {
 			struct ion_cp_heap_pdata *cp_data =
 			   (struct ion_cp_heap_pdata *) shared_heap->extra_data;
-			if (cp_data->fixed_position == FIXED_MIDDLE) {
+			if (cp_data->mem_is_fmem && cp_data->fixed_position == FIXED_MIDDLE) {
 				const struct fmem_data *fmem_info =
 					fmem_get_info();
 
diff --git a/drivers/staging/zcache/Kconfig b/drivers/staging/zcache/Kconfig
index 7048e01..340c1ad 100644
--- a/drivers/staging/zcache/Kconfig
+++ b/drivers/staging/zcache/Kconfig
@@ -2,8 +2,7 @@ config ZCACHE
 	bool "Dynamic compression of swap pages and clean pagecache pages"
 	# X86 dependency is because zsmalloc uses non-portable pte/tlb
 	# functions
-	depends on (CLEANCACHE || FRONTSWAP) && CRYPTO=y && X86
-	select ZSMALLOC
+	depends on (CLEANCACHE || FRONTSWAP) && CRYPTO=y && ZSMALLOC=y
 	select CRYPTO_LZO
 	default n
 	help
diff --git a/drivers/staging/zcache/zcache-main.c b/drivers/staging/zcache/zcache-main.c
index 1812bed..85dab0d 100644
--- a/drivers/staging/zcache/zcache-main.c
+++ b/drivers/staging/zcache/zcache-main.c
@@ -704,19 +704,19 @@ static struct zv_hdr *zv_create(struct zs_pool *pool, uint32_t pool_id,
 
 	BUG_ON(!irqs_disabled());
 	BUG_ON(chunks >= NCHUNKS);
-	handle = zs_malloc(pool, size);
+	handle = (void *)zs_malloc(pool, size);
 	if (!handle)
 		goto out;
 	atomic_inc(&zv_curr_dist_counts[chunks]);
 	atomic_inc(&zv_cumul_dist_counts[chunks]);
-	zv = zs_map_object(pool, handle);
+	zv = zs_map_object(pool, (unsigned long)handle, ZS_MM_RW);
 	zv->index = index;
 	zv->oid = *oid;
 	zv->pool_id = pool_id;
 	zv->size = clen;
 	SET_SENTINEL(zv, ZVH);
 	memcpy((char *)zv + sizeof(struct zv_hdr), cdata, clen);
-	zs_unmap_object(pool, handle);
+	zs_unmap_object(pool, (unsigned long)handle);
 out:
 	return handle;
 }
@@ -728,18 +728,18 @@ static void zv_free(struct zs_pool *pool, void *handle)
 	uint16_t size;
 	int chunks;
 
-	zv = zs_map_object(pool, handle);
+	zv = zs_map_object(pool, (unsigned long)handle, ZS_MM_RW);
 	ASSERT_SENTINEL(zv, ZVH);
 	size = zv->size + sizeof(struct zv_hdr);
 	INVERT_SENTINEL(zv, ZVH);
-	zs_unmap_object(pool, handle);
+	zs_unmap_object(pool, (unsigned long)handle);
 
 	chunks = (size + (CHUNK_SIZE - 1)) >> CHUNK_SHIFT;
 	BUG_ON(chunks >= NCHUNKS);
 	atomic_dec(&zv_curr_dist_counts[chunks]);
 
 	local_irq_save(flags);
-	zs_free(pool, handle);
+	zs_free(pool, (unsigned long)handle);
 	local_irq_restore(flags);
 }
 
@@ -750,14 +750,14 @@ static void zv_decompress(struct page *page, void *handle)
 	int ret;
 	struct zv_hdr *zv;
 
-	zv = zs_map_object(zcache_host.zspool, handle);
+	zv = zs_map_object(zcache_host.zspool, (unsigned long)handle, ZS_MM_RW);
 	BUG_ON(zv->size == 0);
 	ASSERT_SENTINEL(zv, ZVH);
 	to_va = kmap_atomic(page);
 	ret = zcache_comp_op(ZCACHE_COMPOP_DECOMPRESS, (char *)zv + sizeof(*zv),
 				zv->size, to_va, &clen);
 	kunmap_atomic(to_va);
-	zs_unmap_object(zcache_host.zspool, handle);
+	zs_unmap_object(zcache_host.zspool, (unsigned long)handle);
 	BUG_ON(ret);
 	BUG_ON(clen != PAGE_SIZE);
 }
