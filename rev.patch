From bd80111602d8060346ba4d5d0564585bdb54d926 Mon Sep 17 00:00:00 2001
From: robcore <robpatershuk@gmail.com>
Date: Wed, 27 Apr 2016 18:39:46 -0600
Subject: [PATCH] some cleanup-some testing-some fixes because canadian device
 is special needs

---
 arch/arm/mach-msm/board-jf_eur.c             | 56 +++++++++++++++++++----
 arch/arm/mach-msm/include/mach/jf_eur-gpio.h |  9 ++++
 arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c  |  5 +-
 sound/core/seq/seq_timer.c                   |  8 ++--
 sound/soc/codecs/es325.c                     | 71 +++++++++++++++++++++-------
 sound/soc/samsung/dma.c                      |  8 +++-
 sound/soc/samsung/i2s.c                      |  2 +-
 12 files changed, 127 insertions(+), 32 deletions(-)

diff --git a/arch/arm/mach-msm/board-jf_eur.c b/arch/arm/mach-msm/board-jf_eur.c
index 2f52024..8c45813 100644
--- a/arch/arm/mach-msm/board-jf_eur.c
+++ b/arch/arm/mach-msm/board-jf_eur.c
@@ -139,6 +139,10 @@
 #include <linux/leds-max77693.h>
 #endif
 
+#ifdef CONFIG_IRDA_MC96
+#include <linux/ir_remote_con.h>
+#include <linux/regulator/consumer.h>
+#endif
 #ifdef CONFIG_PROC_AVC
 #include <linux/proc_avc.h>
 #endif
@@ -443,6 +447,32 @@ static void irda_vdd_onoff(bool onoff)
 		pr_info("%s irda_vreg 1.8V off is finished.\n", __func__);
 	}
 }
+
+static struct i2c_gpio_platform_data mc96_i2c_gpio_data = {
+	.udelay			= 2,
+	.sda_is_open_drain	= 0,
+	.scl_is_open_drain	= 0,
+	.scl_is_output_only	= 0,
+};
+
+static struct platform_device mc96_i2c_gpio_device = {
+	.name			= "i2c-gpio",
+	.id			= MSM_MC96_I2C_BUS_ID,
+	.dev.platform_data	= &mc96_i2c_gpio_data,
+};
+
+static struct mc96_platform_data mc96_pdata = {
+	.ir_remote_init = irda_device_init,
+	.ir_wake_en = irda_wake_en,
+	.ir_vdd_onoff = irda_vdd_onoff,
+};
+
+static struct i2c_board_info irda_i2c_board_info[] = {
+	{
+		I2C_BOARD_INFO("mc96", (0xA0 >> 1)),
+		.platform_data = &mc96_pdata,
+	},
+};
 #endif
 
 #ifdef CONFIG_KERNEL_MSM_CONTIG_MEM_REGION
@@ -529,7 +559,7 @@ static struct platform_device apq8064_android_pmem_audio_device = {
 static struct platform_device battery_bcl_device = {
 	.name = "battery_current_limit",
 	.id = -1,
-	};
+};
 #endif
 
 struct fmem_platform_data apq8064_fmem_pdata = {
@@ -4123,6 +4153,9 @@ static struct platform_device *common_devices[] __initdata = {
 #ifdef CONFIG_SEC_FPGA
 	&barcode_i2c_gpio_device,
 #endif
+#ifdef CONFIG_IRDA_MC96
+	&mc96_i2c_gpio_device,
+#endif
 #ifdef CONFIG_BATTERY_BCL
 	&battery_bcl_device,
 #endif
@@ -4465,7 +4498,7 @@ static struct msm_i2c_platform_data apq8064_i2c_qup_gsbi3_pdata = {
 };
 
 static struct msm_i2c_platform_data apq8064_i2c_qup_gsbi4_pdata = {
-	.clk_freq = 100000,
+	.clk_freq = 400000,
 	.src_clk_rate = 24000000,
 };
 
@@ -4950,6 +4983,14 @@ static struct i2c_registry apq8064_i2c_devices[] __initdata = {
 		ARRAY_SIZE(leds_i2c_devs),
 	},
 #endif
+#ifdef CONFIG_IRDA_MC96
+	{
+		I2C_FFA,
+		MSM_MC96_I2C_BUS_ID,
+		irda_i2c_board_info,
+		ARRAY_SIZE(irda_i2c_board_info),
+	},
+#endif
 #ifdef CONFIG_SEC_FPGA
 	{
 		I2C_FFA,
@@ -5135,6 +5176,11 @@ static void main_mic_bias_init(void)
 
 static void __init gpio_rev_init(void)
 {
+#if defined(CONFIG_IRDA_MC96)
+	mc96_i2c_gpio_data.sda_pin = gpio_rev(GPIO_IRDA_SDA);
+	mc96_i2c_gpio_data.scl_pin = gpio_rev(GPIO_IRDA_SCL);
+#endif
+
 #ifdef CONFIG_SEC_FPGA
 	barcode_i2c_gpio_data.sda_pin =
 		PM8921_MPP_PM_TO_SYS(PMIC_MPP_FPGA_SPI_SI);
@@ -5473,7 +5519,6 @@ static void __init apq8064_allocate_memory_regions(void)
 
 static void __init apq8064_gpio_keys_init(void)
 {
-	int ret;
 	struct pm_gpio param = {
 		.direction     = PM_GPIO_DIR_IN,
 		.pull          = PM_GPIO_PULL_UP_31P5,
@@ -5488,11 +5533,8 @@ static void __init apq8064_gpio_keys_init(void)
 		.vin_sel       = PM_GPIO_VIN_S4,
 		.function      = PM_GPIO_FUNC_NORMAL,
 	};
-	ret = gpio_request(PM8921_GPIO_PM_TO_SYS(PMIC_GPIO_HALL_SENSOR_INT),
+	gpio_request(PM8921_GPIO_PM_TO_SYS(PMIC_GPIO_HALL_SENSOR_INT),
 						"GPIO_HALL_SENSOR_INT");
-	if (ret)
-		pr_err("%s : gpio_request failed for %d\n", __func__,
-			PM8921_GPIO_PM_TO_SYS(PMIC_GPIO_HALL_SENSOR_INT));
 	pm8xxx_gpio_config(PM8921_GPIO_PM_TO_SYS(PMIC_GPIO_HALL_SENSOR_INT),
 						&param_hall_ic);
 #endif
diff --git a/arch/arm/mach-msm/include/mach/jf_eur-gpio.h b/arch/arm/mach-msm/include/mach/jf_eur-gpio.h
index 72502b8..4a73648 100644
--- a/arch/arm/mach-msm/include/mach/jf_eur-gpio.h
+++ b/arch/arm/mach-msm/include/mach/jf_eur-gpio.h
@@ -121,6 +121,15 @@ enum {
 	GPIO_REV_MAX,
 };
 
+/* GPIO array Index */
+enum {
+	GPIO_FPGA_EN,
+	GPIO_BARCODE_SDA,
+	GPIO_BARCODE_SCL,
+	GPIO_IRDA_SDA,
+	GPIO_IRDA_SCL,
+};
+
 enum {
 	FPGA_VSIL_A_1P2_EN = 0,
 	FPGA_GPIO_01,
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c b/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
index fc915a6..639c9b5 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
@@ -1148,7 +1148,10 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	}
 	case AUDIO_ASYNC_READ: {
 		mutex_lock(&audio->read_lock);
-		if (audio->feedback)
+/*original is 
+if (audio->feedback)
+this is merely a test*/
+		if ((audio->feedback) && (audio->enabled))
 			rc = audio_aio_buf_add(audio, 0,
 					(void __user *)arg);
 		else
diff --git a/sound/core/seq/seq_timer.c b/sound/core/seq/seq_timer.c
index 24d44b2..160b1bd 100644
--- a/sound/core/seq/seq_timer.c
+++ b/sound/core/seq/seq_timer.c
@@ -290,10 +290,10 @@ int snd_seq_timer_open(struct snd_seq_queue *q)
 			tid.device = SNDRV_TIMER_GLOBAL_SYSTEM;
 			err = snd_timer_open(&t, str, &tid, q->queue);
 		}
-	}
-	if (err < 0) {
-		snd_printk(KERN_ERR "seq fatal error: cannot create timer (%i)\n", err);
-		return err;
+		if (err < 0) {
+			snd_printk(KERN_ERR "seq fatal error: cannot create timer (%i)\n", err);
+			return err;
+		}
 	}
 	t->callback = snd_seq_timer_interrupt;
 	t->callback_data = q;
diff --git a/sound/soc/codecs/es325.c b/sound/soc/codecs/es325.c
index 304748b..c78ebbd 100644
--- a/sound/soc/codecs/es325.c
+++ b/sound/soc/codecs/es325.c
@@ -99,6 +99,14 @@ struct es325_cmd_access {
 #define NS_OFFSET 2
 
 #define ES325_NUM_CODEC_SLIM_DAIS	6
+int debug_for_dl_firmware = 0;
+
+enum {
+	BOOT_OK = 0,
+	BOOT_MSG_ERR,
+	BOOT_MSG_NACK,
+	SYNC_MSG_NACK
+};
 
 struct es325_slim_dai_data {
 	unsigned int rate;
@@ -181,6 +189,7 @@ static unsigned int es325_ap_tx1_ch_cnt = 1;
 unsigned int es325_tx1_route_enable;
 unsigned int es325_rx1_route_enable;
 unsigned int es325_rx2_route_enable;
+unsigned int es325_fw_downloaded = 0;
 
 static int es325_slim_rx_port_to_ch[ES325_SLIM_RX_PORTS] = {
 	152, 153, 154, 155, 134, 135
@@ -872,6 +881,10 @@ int es325_remote_cfg_slim_rx(int dai_id)
 	struct es325_priv *es325 = &es325_priv;
 	int be_id;
 	int rc = 0;
+	if(es325_fw_downloaded == 0) {
+		pr_err("%s():eS325 FW not ready, cfg_slim_rx rejected\n", __func__);
+		return rc;
+	}
 
 	if (dai_id != ES325_SLIM_1_PB
 	    && dai_id != ES325_SLIM_2_PB)
@@ -918,6 +931,10 @@ int es325_remote_cfg_slim_tx(int dai_id)
 	int ch_cnt;
 	int rc = 0;
 
+	if(es325_fw_downloaded == 0) {
+		pr_err("%s():eS325 FW not ready, cfg_slim_tx rejected\n", __func__);
+		return rc;
+	}
 	if (dai_id != ES325_SLIM_1_CAP)
 		return 0;
 
@@ -2057,10 +2074,12 @@ static int es325_bootup(struct es325_priv *es325)
 	if (rc < 0) {
 		pr_err("%s(): ES325_BUS_READ_ERROR = %d\n", __func__,rc);
 		pr_err("%s(): firmware load failed boot ack\n", __func__);
+		debug_for_dl_firmware = BOOT_MSG_ERR;
 		return	rc;
 	}
 	if ((msg[0] != (ES325_BOOT_ACK >> 8)) || (msg[1] != (ES325_BOOT_ACK & 0x00ff))) {
 		pr_err("%s(): firmware load failed boot ack pattern", __func__);
+		debug_for_dl_firmware = BOOT_MSG_NACK;
 		return	-EIO;
 	}
 	usleep_range(50000, 50000);
@@ -2077,6 +2096,7 @@ static int es325_bootup(struct es325_priv *es325)
 		if (rc < 0) {
 			pr_err("%s(): ES325_BUS_WRITE_ERROR = %d\n", __func__,rc);
 			pr_err("%s(): firmware load failed\n", __func__);
+			debug_for_dl_firmware = buf_frames * ES325_FW_LOAD_BUF_SZ;
 			return -EIO;
 		}
 	}
@@ -2087,6 +2107,7 @@ static int es325_bootup(struct es325_priv *es325)
 		if (rc < 0) {
 			pr_err("%s(): ES325_BUS_WRITE_ERROR = %d\n", __func__,rc);
 			pr_err("%s(): firmware load failed\n", __func__);
+			debug_for_dl_firmware = es325->fw->size % ES325_FW_LOAD_BUF_SZ;
 			return -EIO;
 		}
 	}
@@ -2124,14 +2145,17 @@ static int es325_bootup(struct es325_priv *es325)
 		pr_err("%s(): ES325_BUS_READ_ERROR = %d\n", __func__,rc);
 		pr_err("%s(): error reading firmware sync ack rc=%d\n",
 		       __func__, rc);
+		debug_for_dl_firmware = SYNC_MSG_NACK;
 		return rc;
 	}
 	if (memcmp(msg, sync_ok, 4) == 0) {
 		pr_info("%s(): firmware sync ack good=0x%02x%02x%02x%02x\n",
 			__func__, msg[0], msg[1], msg[2], msg[3]);
+		es325_fw_downloaded = 1;
 	} else {
 		pr_err("%s(): firmware sync ack failed=0x%02x%02x%02x%02x\n",
 		       __func__, msg[0], msg[1], msg[2], msg[3]);
+		debug_for_dl_firmware = SYNC_MSG_NACK;
 		return -EIO;
 	}
 
@@ -2287,34 +2311,41 @@ static DEVICE_ATTR(firmware, 0644, NULL, es325_firmware_store);
 
 static int es325_sleep(struct es325_priv *es325)
 {
+	char smooth_rate_cmd[] = {
+		0x90, 0x4e, 0x00, 0x00 /* response not expected */
+	};
 	char pwr_cmd[] = {
-		0x90, 0x10, 0, 1
+		0x90, 0x10, 0x00, 0x01 /* response not expected */
 	};
+
 	int rc;
-	int remain = 3;
+	int i = 0;
 
 	pr_info("+[ES325]=%s()=\n", __func__);
 
-	/* FIXME: check host vs bus ordering in the write. Why is this
-	 * still so confused?
-	 */
-LOOP:
+	/* Set Smooth Mute period to 0 ms */
 	rc = ES325_BUS_WRITE(es325, ES325_WRITE_VE_OFFSET,
+				ES325_WRITE_VE_WIDTH, smooth_rate_cmd, 4, 1);
+	if (rc < 0)
+		pr_err("=[ES325]=%s(): Sleep Smooth Mute Set to 0 Fail, rc=%d\n", __func__, rc);
+
+	usleep_range(2000, 2100);
+
+	/* write pwr command, es325 to sleep mode */
+	do {
+		rc = ES325_BUS_WRITE(es325, ES325_WRITE_VE_OFFSET,
 			     ES325_WRITE_VE_WIDTH, pwr_cmd, 4, 1);
-	if (rc < 0) {
-		if (-remain > 0) {
-			pr_info("=[ES325]= wrapper %s sleep command failed remain count %d\n",
-				__func__, remain);
-			usleep_range(1000, 1100);
-			goto LOOP;
+		if (rc == 0) {
+			/* wait 20 ms according to spec end return. 
+			   eS325 is sleeping */
+			msleep(20);
+			break;
 		}
-	}
+		pr_err("=[ES325]=%s(): slim write fail, rc=%d\n", __func__,rc);
+		usleep_range(1000, 1000);
+		i++;
+	} while (i <= 20);
 
-	if (rc < 0) {
-		pr_err("=[ES325]= error sending sleep cmd rc=%d\n", rc);
-		return rc;
-	}
-	usleep_range(20000, 20000);
 
 	pr_info("-[ES325]=%s()=\n", __func__);
 	return 0;
@@ -5177,6 +5208,10 @@ void es325_wrapper_wakeup(struct snd_soc_dai *dai)
 #ifdef ES325_SLEEP
 	int rc;
 	struct es325_priv *es325 = &es325_priv;
+	if(es325_fw_downloaded==0) {
+		pr_err("%s():FW not ready, wakeup suspends, err_msg:%d\n", __func__,debug_for_dl_firmware);
+		return;
+	}
 	pr_debug("=[ES325]=%s dai_id=%d ch_wakeup=%d,wakeup_cnt=%d\n", __func__,
 		dai->id, es325->dai[dai->id-1].ch_wakeup, es325->wakeup_cnt);
 	if (!es325_remote_route_enable(dai)) {
diff --git a/sound/soc/samsung/dma.c b/sound/soc/samsung/dma.c
index 2526eca..ddc6cde 100644
--- a/sound/soc/samsung/dma.c
+++ b/sound/soc/samsung/dma.c
@@ -34,7 +34,9 @@ static const struct snd_pcm_hardware dma_hardware = {
 	.info			= SNDRV_PCM_INFO_INTERLEAVED |
 				    SNDRV_PCM_INFO_BLOCK_TRANSFER |
 				    SNDRV_PCM_INFO_MMAP |
-				    SNDRV_PCM_INFO_MMAP_VALID,
+				    SNDRV_PCM_INFO_MMAP_VALID |
+				    SNDRV_PCM_INFO_PAUSE |
+				    SNDRV_PCM_INFO_RESUME,
 	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
 				    SNDRV_PCM_FMTBIT_U16_LE |
 				    SNDRV_PCM_FMTBIT_U8 |
@@ -244,11 +246,15 @@ static int dma_trigger(struct snd_pcm_substream *substream, int cmd)
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		prtd->state |= ST_RUNNING;
 		prtd->params->ops->trigger(prtd->params->ch);
 		break;
 
 	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		prtd->state &= ~ST_RUNNING;
 		prtd->params->ops->stop(prtd->params->ch);
 		break;
diff --git a/sound/soc/samsung/i2s.c b/sound/soc/samsung/i2s.c
index 9998719..6ac7b82 100644
--- a/sound/soc/samsung/i2s.c
+++ b/sound/soc/samsung/i2s.c
@@ -392,7 +392,7 @@ static int i2s_set_sysclk(struct snd_soc_dai *dai,
 		if (dir == SND_SOC_CLOCK_IN)
 			rfs = 0;
 
-		if ((rfs && other && other->rfs && (other->rfs != rfs)) ||
+		if ((rfs && other->rfs && (other->rfs != rfs)) ||
 				(any_active(i2s) &&
 				(((dir == SND_SOC_CLOCK_IN)
 					&& !(mod & MOD_CDCLKCON)) ||
