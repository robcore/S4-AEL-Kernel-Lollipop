From 593ec1ab172b1cfe81fbdb03f0050ffec492689f Mon Sep 17 00:00:00 2001
From: robcore <robpatershuk@gmail.com>
Date: Thu, 28 Apr 2016 17:26:54 -0600
Subject: [PATCH 49/50] From fc35f15710e5df510c129c6df7cb84c1801beff1 Mon Sep
 17 00:00:00 2001 From: Chris Fries <C.Fries@motorola.com> Date: Wed, 27 Mar
 2013 12:26:12 -0500 Subject: [PATCH 210/292] sched: Limit setaffinity with
 CPU_HOTPLUG

Some applications do not count CPU's correctly and make bad
decisions on systems with hotplugged CPU's.

Limit app's ability to use setaffinity based on CONFIG_CPU_HOTPLUG.

Change-Id: I133cff0c0c71553ca1febfb044dba59bda38cb33
Signed-off-by: Chris Fries <C.Fries@motorola.com>
Reviewed-on: http://gerrit.pcs.mot.com/528092
SLT-Approved: Gerrit Code Review <gerrit-blurdev@motorola.com>
Tested-by: Jira Key <jirakey@motorola.com>
Reviewed-by: Christopher Fries <qcf001@motorola.com>
Reviewed-by: Jeffrey Carlyle <jeff.carlyle@motorola.com>
Reviewed-by: Klocwork kwcheck <klocwork-kwcheck@sourceforge.mot.com>
Reviewed-by: Igor Kovalenko <cik009@motorola.com>
Submit-Approved: Jira Key <jirakey@motorola.com>
Signed-off-by: Luis Cruz <ljc2491@gmail.com>
Signed-off-by: Jake Weinstein <xboxlover360@gmail.com>
---
 kernel/sched/core.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index fce8a9c..5de9ec8 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -3407,6 +3407,15 @@ long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
 	if (!check_same_owner(p) && !ns_capable(task_user_ns(p), CAP_SYS_NICE))
 		goto out_unlock;

+#ifdef CONFIG_HOTPLUG_CPU
+	if (!ns_capable(task_user_ns(p), CAP_SYS_NICE)) {
+		/* Silent fail.  No scenario for affinity makes sense
+		 * for unpriviledged users with hotplugged CPU's.
+		 */
+		retval = 0;
+		goto out_unlock;
+	}
+#endif
 	retval = security_task_setscheduler(p);
 	if (retval)
 		goto out_unlock;
--
2.8.0.rc3
---
 arch/arm/Kconfig.debug   | 2 +-
 kernel/sched/core.c      | 9 +++++++++
 kernel/sched/core.c.orig | 4 ++++
 3 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug
index ad0941a..c05fca7 100755
--- a/arch/arm/Kconfig.debug
+++ b/arch/arm/Kconfig.debug
@@ -44,7 +44,7 @@ config ARM_UNWIND
 config OLD_MCOUNT
 	bool
 	depends on FUNCTION_TRACER && FRAME_POINTER
-	default y
+	default n
 
 config DEBUG_USER
 	bool "Verbose user fault messages"
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index c23ca25..cd622b5 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4961,6 +4961,15 @@ long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
 	if (!check_same_owner(p) && !ns_capable(task_user_ns(p), CAP_SYS_NICE))
 		goto out_unlock;
 
+#ifdef CONFIG_HOTPLUG_CPU
+	if (!ns_capable(task_user_ns(p), CAP_SYS_NICE)) {
+		/* Silent fail.  No scenario for affinity makes sense
+		 * for unpriviledged users with hotplugged CPU's.
+		 */
+		retval = 0;
+		goto out_unlock;
+	}
+#endif
 	retval = security_task_setscheduler(p);
 	if (retval)
 		goto out_unlock;
diff --git a/kernel/sched/core.c.orig b/kernel/sched/core.c.orig
index 3202009..c23ca25 100644
--- a/kernel/sched/core.c.orig
+++ b/kernel/sched/core.c.orig
@@ -120,6 +120,10 @@ DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);
 DEFINE_PER_CPU_SHARED_ALIGNED(struct nr_stats_s, runqueue_stats);
 #endif
 
+#ifdef CONFIG_INTELLI_PLUG
+DEFINE_PER_CPU_SHARED_ALIGNED(struct nr_stats_s, runqueue_stats);
+#endif
+
 static void update_rq_clock_task(struct rq *rq, s64 delta);
 
 void update_rq_clock(struct rq *rq)
-- 
2.8.0.rc3

