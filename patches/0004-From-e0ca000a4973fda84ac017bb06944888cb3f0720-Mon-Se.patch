From f5375bb85242f9112ed402fb2c33297b0f27c3a6 Mon Sep 17 00:00:00 2001
From: robcore <robpatershuk@gmail.com>
Date: Thu, 28 Apr 2016 13:51:02 -0600
Subject: [PATCH 04/50] From e0ca000a4973fda84ac017bb06944888cb3f0720 Mon Sep
 17 00:00:00 2001 From: Kirill Tkhai <tkhai@yandex.ru> Date: Wed, 30 Jan 2013
 16:50:36 +0400 Subject: [PATCH 188/240] sched/rt: Do not account zero
 delta_exec in  update_curr_rt()

There are several places of consecutive calls of
dequeue_task_rt() and put_prev_task_rt() in the scheduler.
For example, function rt_mutex_setprio() does it.

The both calls lead to update_curr_rt(), the second of it
receives zeroed delta_exec. The only effective action in this
case is call of sched_rt_avg_update(), which can change
rq->age_stamp and rq->rt_avg. But it is possible in case of
""floating"" rq->clock. This fact is not reasonable to be
accounted. Another actions do nothing.

Signed-off-by: Kirill V Tkhai <tkhai@yandex.ru>
Acked-by: Steven Rostedt <rostedt@goodmis.org>
Cc: Peter Zijlstra <peterz@infradead.org>
CC: linux-rt-users <linux-rt-users@vger.kernel.org>
Link: http://lkml.kernel.org/r/931541359550236@web1g.yandex.ru
Signed-off-by: Ingo Molnar <mingo@kernel.org>
---
 kernel/sched/rt.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 17b0b17..f527b64 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -940,8 +940,8 @@ static void update_curr_rt(struct rq *rq)
 		return;

 	delta_exec = rq->clock_task - curr->se.exec_start;
-	if (unlikely((s64)delta_exec < 0))
-		delta_exec = 0;
+	if (unlikely((s64)delta_exec <= 0))
+		return;

 	schedstat_set(curr->se.statistics.exec_max,
 		      max(curr->se.statistics.exec_max, delta_exec));
--
2.8.0.rc3
---
 kernel/sched/rt.c      | 4 ++--
 kernel/sched/rt.c.orig | 6 +++++-
 2 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 5b73788..8811fdc 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -900,8 +900,8 @@ static void update_curr_rt(struct rq *rq)
 		return;
 
 	delta_exec = rq->clock_task - curr->se.exec_start;
-	if (unlikely((s64)delta_exec < 0))
-		delta_exec = 0;
+	if (unlikely((s64)delta_exec <= 0))
+		return;
 
 	schedstat_set(curr->se.statistics.exec_max,
 		      max(curr->se.statistics.exec_max, delta_exec));
diff --git a/kernel/sched/rt.c.orig b/kernel/sched/rt.c.orig
index b66914c..5b73788 100644
--- a/kernel/sched/rt.c.orig
+++ b/kernel/sched/rt.c.orig
@@ -2020,7 +2020,11 @@ static void watchdog(struct rq *rq, struct task_struct *p)
 	if (soft != RLIM_INFINITY) {
 		unsigned long next;
 
-		p->rt.timeout++;
+		if (p->rt.watchdog_stamp != jiffies) {
+			p->rt.timeout++;
+			p->rt.watchdog_stamp = jiffies;
+		}
+
 		next = DIV_ROUND_UP(min(soft, hard), USEC_PER_SEC/HZ);
 		if (p->rt.timeout > next)
 			p->cputime_expires.sched_exp = p->se.sum_exec_runtime;
-- 
2.8.0.rc3

