From e97f01dec9953c25f535cb830e7ea7b82aad0301 Mon Sep 17 00:00:00 2001
From: friedrich420 <kelpidorou@yahoo.com>
Date: Sun, 7 Feb 2016 15:42:52 +0200
Subject: [PATCH] mm: fix aio performance regression for database caused by THP
 [Khalid Aziz]

---
 include/linux/huge_mm.h | 19 +++++++++++++++++++
 mm/swap.c               | 29 ++++++++++++++++++++++++++++-
 2 files changed, 47 insertions(+), 1 deletion(-)

diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h
index a193bb3..ec601e0 100644
--- a/include/linux/huge_mm.h
+++ b/include/linux/huge_mm.h
@@ -160,6 +160,24 @@ static inline int hpage_nr_pages(struct page *page)
 	return 1;
 }
 
+static inline struct page *compound_trans_head(struct page *page)
+{
+	if (PageTail(page)) {
+		struct page *head;
+		head = page->first_page;
+		smp_rmb();
+		/*
+		 * head may be a dangling pointer.
+		 * __split_huge_page_refcount clears PageTail before
+		 * overwriting first_page, so if PageTail is still
+		 * there it means the head pointer isn't dangling.
+		 */
+		if (PageTail(page))
+			return head;
+	}
+	return page;
+}
+
 extern int do_huge_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,
 				unsigned long addr, pmd_t pmd, pmd_t *pmdp);
 
@@ -188,6 +206,7 @@ static inline int split_huge_page(struct page *page)
 	do { } while (0)
 #define split_huge_page_pmd_mm(__mm, __address, __pmd)	\
 	do { } while (0)
+#define compound_trans_head(page) compound_head(page)
 static inline int hugepage_madvise(struct vm_area_struct *vma,
 				   unsigned long *vm_flags, int advice)
 {
diff --git a/mm/swap.c b/mm/swap.c
index 4e35f3f..73c3221 100644
--- a/mm/swap.c
+++ b/mm/swap.c
@@ -79,6 +79,20 @@ static void __put_compound_page(struct page *page)
 
 static void put_compound_page(struct page *page)
 {
+
+	/*
+	 * hugetlbfs pages cannot be split from under us.  If this is a
+	 * hugetlbfs page, check refcount on head page and release the page if
+	 * the refcount becomes zero.
+	 */
+	if (PageHuge(page)) {
+		page = compound_head(page);
+		if (put_page_testzero(page))
+			__put_compound_page(page);
+		return;
+	}
+	
+
 	if (unlikely(PageTail(page))) {
 		/* __split_huge_page_refcount can run under us */
 		struct page *page_head = compound_head(page);
@@ -219,8 +233,20 @@ bool __get_page_tail(struct page *page)
 	 */
 	unsigned long flags;
 	bool got = false;
-	struct page *page_head = compound_head(page);
+	struct page *page_head;
 
+	/*
+	 * If this is a hugetlbfs page it cannot be split under us.  Simply
+	 * increment refcount for the head page.
+	 */
+	if (PageHuge(page)) {
+		page_head = compound_head(page);
+		atomic_inc(&page_head->_count);
+		got = true;
+		goto out;
+	}
+  
+	page_head = compound_trans_head(page);
 	if (likely(page != page_head && get_page_unless_zero(page_head))) {
 		/* Ref to put_compound_page() comment. */
 		if (PageSlab(page_head) || PageHeadHuge(page_head)) {
@@ -264,6 +290,7 @@ bool __get_page_tail(struct page *page)
 		if (unlikely(!got))
 			put_page(page_head);
 	}
+out:
 	return got;
 }
 EXPORT_SYMBOL(__get_page_tail);
