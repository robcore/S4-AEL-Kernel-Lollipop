From 62ca97c55e3e872a4c3987e6e9b3e21b6c9134e4 Mon Sep 17 00:00:00 2001
From: Anji Jonnala <anjir@codeaurora.org>
Date: Thu, 25 Sep 2014 16:39:41 +0530
Subject: [PATCH] msm: thermal: Store temperature of tsens on kernel panic
 notification

Register KTM with panic notifier with a callback on boot and
on callback store all tsens temperature into static variable.
This will help rule out or confirm role of thermal for any
kernel crash.

Signed-off-by: Anji Jonnala <anjir@codeaurora.org>
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 drivers/thermal/msm_thermal.c | 44 +++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 42 insertions(+), 2 deletions(-)

diff --git a/drivers/thermal/msm_thermal.c b/drivers/thermal/msm_thermal.c
index 09cceb5..b63fd68 100644
--- a/drivers/thermal/msm_thermal.c
+++ b/drivers/thermal/msm_thermal.c
@@ -97,6 +97,7 @@ static struct kobj_attribute cx_mode_attr;
 static struct kobj_attribute gfx_mode_attr;
 static struct attribute_group cx_attr_gp;
 static struct attribute_group gfx_attr_gp;
+static long *tsens_temp_at_panic;
 
 enum thermal_threshold {
 	HOTPLUG_THRESHOLD_HIGH,
@@ -929,6 +930,23 @@ static int therm_get_temp(uint32_t id, enum sensor_id_type type, long *temp)
 	return ret;
 }
 
+static int msm_thermal_panic_callback(struct notifier_block *nfb,
+			unsigned long event, void *data)
+{
+	int i;
+
+	for (i = 0; i < max_tsens_num; i++)
+		therm_get_temp(tsens_id_map[i],
+				THERM_TSENS_ID,
+				&tsens_temp_at_panic[i]);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block msm_thermal_panic_notifier = {
+	.notifier_call = msm_thermal_panic_callback,
+};
+
 static int set_threshold(uint32_t zone_id,
 	struct sensor_threshold *threshold)
 {
@@ -2466,7 +2484,26 @@ static __init int msm_thermal_add_cc_nodes(void)
 	return ret;
 }
 
-int msm_thermal_pre_init(void)
+static void msm_thermal_panic_notifier_init(struct device *dev)
+{
+	int i;
+
+	tsens_temp_at_panic = devm_kzalloc(dev,
+				sizeof(long) * max_tsens_num,
+				GFP_KERNEL);
+	if (!tsens_temp_at_panic) {
+		pr_err("kzalloc failed\n");
+		return;
+	}
+
+	for (i = 0; i < max_tsens_num; i++)
+		tsens_temp_at_panic[i] = LONG_MIN;
+
+	atomic_notifier_chain_register(&panic_notifier_list,
+		&msm_thermal_panic_notifier);
+}
+
+int msm_thermal_pre_init(struct device *dev)
 {
 	int ret = 0;
 
@@ -2487,6 +2524,9 @@ int msm_thermal_pre_init(void)
 		goto pre_init_exit;
 	}
 
+	if (!tsens_temp_at_panic)
+		msm_thermal_panic_notifier_init(dev);
+
 	if (!thresh) {
 		thresh = kzalloc(
 				sizeof(struct threshold_info) * MSM_LIST_MAX_NR,
@@ -3261,7 +3301,7 @@ static int msm_thermal_dev_probe(struct platform_device *pdev)
 	struct msm_thermal_data data;
 
 	memset(&data, 0, sizeof(struct msm_thermal_data));
-	ret = msm_thermal_pre_init();
+	ret = msm_thermal_pre_init(&pdev->dev);
 	if (ret) {
 		pr_err("thermal pre init failed. err:%d\n", ret);
 		goto fail;
