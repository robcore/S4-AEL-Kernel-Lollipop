From 7044a3425557a9e8ab929d84c5602fd5ab134b7b Mon Sep 17 00:00:00 2001
From: Steve Muckle <smuckle@codeaurora.org>
Date: Thu, 23 May 2013 15:24:57 -0700
Subject: [PATCH] sched: remove migration notification from RT class

Commit 88a7e37d265 (sched: provide per cpu-cgroup option to
notify on migrations) added a notifier call when a task is moved
to a different CPU. Unfortunately the two call sites in the RT
sched class where this occurs happens with a runqueue lock held.
This can result in a deadlock if the notifier call attempts to do
something like wake up a task.

Fortunately the benefit of 88a7e37d265 comes mainly from notifying
on migration of non-RT tasks, so we can simply ignore the movements
of RT tasks.

CRs-Fixed: 491370
Change-Id: I8849d826bf1eeaf85a6f6ad872acb475247c5926
Signed-off-by: Steve Muckle <smuckle@codeaurora.org>
---
 kernel/sched/rt.c | 20 +-------------------
 1 file changed, 1 insertion(+), 19 deletions(-)

diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 8390567..b581c65 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -1619,7 +1619,6 @@ static int push_rt_task(struct rq *rq)
 	struct task_struct *next_task;
 	struct rq *lowest_rq;
 	int ret = 0;
-	bool moved = false;
 
 	if (!rq->rt.overloaded)
 		return 0;
@@ -1689,7 +1688,6 @@ static int push_rt_task(struct rq *rq)
 
 	deactivate_task(rq, next_task, 0);
 	set_task_cpu(next_task, lowest_rq->cpu);
-	moved = true;
 	activate_task(lowest_rq, next_task, 0);
 	ret = 1;
 
@@ -1700,11 +1698,6 @@ static int push_rt_task(struct rq *rq)
 out:
 	put_task_struct(next_task);
 
-	if (moved && task_notify_on_migrate(next_task))
-		atomic_notifier_call_chain(&migration_notifier_head,
-					   cpu_of(lowest_rq),
-					   (void *)cpu_of(rq));
-
 	return ret;
 }
 
@@ -1718,10 +1711,8 @@ static void push_rt_tasks(struct rq *rq)
 static int pull_rt_task(struct rq *this_rq)
 {
 	int this_cpu = this_rq->cpu, ret = 0, cpu;
-	struct task_struct *p = NULL;
+	struct task_struct *p;
 	struct rq *src_rq;
-	bool moved = false;
-	int src_cpu = 0;
 
 	if (likely(!rt_overloaded(this_rq)))
 		return 0;
@@ -1782,10 +1773,6 @@ static int pull_rt_task(struct rq *this_rq)
 			deactivate_task(src_rq, p, 0);
 			set_task_cpu(p, this_cpu);
 			activate_task(this_rq, p, 0);
-
-			moved = true;
-			src_cpu = cpu_of(src_rq);
-
 			/*
 			 * We continue with the search, just in
 			 * case there's an even higher prio task
@@ -1797,11 +1784,6 @@ static int pull_rt_task(struct rq *this_rq)
 		double_unlock_balance(this_rq, src_rq);
 	}
 
-	if (moved && task_notify_on_migrate(p))
-		atomic_notifier_call_chain(&migration_notifier_head,
-					   this_cpu,
-					   (void *)src_cpu);
-
 	return ret;
 }
 
