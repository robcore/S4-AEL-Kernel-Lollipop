From 55788315373254b5197a0423593039137017ed76 Mon Sep 17 00:00:00 2001
From: Pranav Vashi <neobuddy89@gmail.com>
Date: Tue, 23 Jun 2015 00:27:57 +0530
Subject: [PATCH] msm: Clean-up hotplug drivers

* New state notifier driver supports suspend defer time.
* Chuck the repeated code from hotplug drivers.

Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 arch/arm/mach-msm/bricked_hotplug.c |  93 +++-------------------------
 arch/arm/mach-msm/intelli_hotplug.c |  97 +++--------------------------
 arch/arm/mach-msm/msm_hotplug.c     | 118 +++---------------------------------
 3 files changed, 22 insertions(+), 286 deletions(-)

diff --git a/arch/arm/mach-msm/bricked_hotplug.c b/arch/arm/mach-msm/bricked_hotplug.c
index 91ac4e4..41ef471 100644
--- a/arch/arm/mach-msm/bricked_hotplug.c
+++ b/arch/arm/mach-msm/bricked_hotplug.c
@@ -25,8 +25,6 @@
 #include <linux/device.h>
 #ifdef CONFIG_STATE_NOTIFIER
 #include <linux/state_notifier.h>
-#else
-#include <linux/fb.h>
 #endif
 
 #define DEBUG 0
@@ -52,10 +50,7 @@ enum {
 
 static struct notifier_block notif;
 static struct delayed_work hotplug_work;
-static struct delayed_work suspend_work;
-static struct work_struct resume_work;
 static struct workqueue_struct *hotplug_wq;
-static struct workqueue_struct *susp_wq;
 
 static struct cpu_hotplug {
 	unsigned int startdelay;
@@ -252,7 +247,7 @@ static void __ref bricked_hotplug_work(struct work_struct *work) {
 	return;
 }
 
-static void bricked_hotplug_suspend(struct work_struct *work)
+static void bricked_hotplug_suspend(void)
 {
 	int cpu;
 
@@ -281,7 +276,7 @@ static void bricked_hotplug_suspend(struct work_struct *work)
 			cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
 }
 
-static void __ref bricked_hotplug_resume(struct work_struct *work)
+static void __ref bricked_hotplug_resume(void)
 {
 	int cpu, required_reschedule = 0, required_wakeup = 0;
 
@@ -317,36 +312,19 @@ static void __ref bricked_hotplug_resume(struct work_struct *work)
 	}
 }
 
-static void __bricked_hotplug_resume(void)
-{
-	if (!hotplug.bricked_enabled)
-		return;
-
-	flush_workqueue(susp_wq);
-	cancel_delayed_work_sync(&suspend_work);
-	queue_work_on(0, susp_wq, &resume_work);
-}
-
-static void __bricked_hotplug_suspend(void)
-{
-	if (!hotplug.bricked_enabled || hotplug.suspended)
-		return;
-
-	INIT_DELAYED_WORK(&suspend_work, bricked_hotplug_suspend);
-	queue_delayed_work_on(0, susp_wq, &suspend_work, 
-		msecs_to_jiffies(hotplug.suspend_defer_time * 1000)); 
-}
-
 #ifdef CONFIG_STATE_NOTIFIER
 static int state_notifier_callback(struct notifier_block *this,
 				unsigned long event, void *data)
 {
+	if (!hotplug.bricked_enabled)
+		return NOTIFY_OK;
+
 	switch (event) {
 		case STATE_NOTIFIER_ACTIVE:
-			__bricked_hotplug_resume();
+			bricked_hotplug_resume();
 			break;
 		case STATE_NOTIFIER_SUSPEND:
-			__bricked_hotplug_suspend();
+			bricked_hotplug_suspend();
 			break;
 		default:
 			break;
@@ -354,35 +332,6 @@ static int state_notifier_callback(struct notifier_block *this,
 
 	return NOTIFY_OK;
 }
-#else
-static int prev_fb = FB_BLANK_UNBLANK;
-
-static int fb_notifier_callback(struct notifier_block *self,
-				unsigned long event, void *data)
-{
-	struct fb_event *evdata = data;
-	int *blank;
-
-	if (evdata && evdata->data && event == FB_EVENT_BLANK) {
-		blank = evdata->data;
-		switch (*blank) {
-			case FB_BLANK_UNBLANK:
-				if (prev_fb == FB_BLANK_POWERDOWN) {
-					__bricked_hotplug_resume();
-					prev_fb = FB_BLANK_UNBLANK;
-				}
-				break;
-			case FB_BLANK_POWERDOWN:
-				if (prev_fb == FB_BLANK_UNBLANK) {
-					__bricked_hotplug_suspend();
-					prev_fb = FB_BLANK_POWERDOWN;
-				}
-				break;
-		}
-	}
-
-	return NOTIFY_OK;
-}
 #endif
 
 static int bricked_hotplug_start(void)
@@ -396,28 +345,12 @@ static int bricked_hotplug_start(void)
 		goto err_out;
 	}
 
-	susp_wq =
-	    alloc_workqueue("susp_wq", WQ_FREEZABLE, 0);
-	if (!susp_wq) {
-		pr_err("%s: Failed to allocate suspend workqueue\n",
-		       MPDEC_TAG);
-		ret = -ENOMEM;
-		goto err_dev;
-	}
-
 #ifdef CONFIG_STATE_NOTIFIER
 	notif.notifier_call = state_notifier_callback;
 	if (state_register_client(&notif)) {
 		pr_err("%s: Failed to register State notifier callback\n",
 			MPDEC_TAG);
-		goto err_susp;
-	}
-#else
-	notif.notifier_call = fb_notifier_callback;
-	if (fb_register_client(&notif)) {
-		pr_err("%s: Failed to register FB notifier callback\n",
-			MPDEC_TAG);
-		goto err_susp;
+		goto err_dev;
 	}
 #endif
 
@@ -425,8 +358,6 @@ static int bricked_hotplug_start(void)
 	mutex_init(&hotplug.bricked_hotplug_mutex);
 
 	INIT_DELAYED_WORK(&hotplug_work, bricked_hotplug_work);
-	INIT_DELAYED_WORK(&suspend_work, bricked_hotplug_suspend);
-	INIT_WORK(&resume_work, bricked_hotplug_resume);
 
 	for_each_possible_cpu(cpu) {
 		dl = &per_cpu(lock_info, cpu);
@@ -438,8 +369,6 @@ static int bricked_hotplug_start(void)
 					msecs_to_jiffies(hotplug.startdelay));
 
 	return ret;
-err_susp:
-	destroy_workqueue(susp_wq);
 err_dev:
 	destroy_workqueue(hotplug_wq);
 err_out:
@@ -457,19 +386,13 @@ static void bricked_hotplug_stop(void)
 		cancel_delayed_work_sync(&dl->lock_rem);
 	}
 
-	flush_workqueue(susp_wq);
-	cancel_work_sync(&resume_work);
-	cancel_delayed_work_sync(&suspend_work);
 	cancel_delayed_work_sync(&hotplug_work);
 	mutex_destroy(&hotplug.bricked_hotplug_mutex);
 	mutex_destroy(&hotplug.bricked_cpu_mutex);
 #ifdef CONFIG_STATE_NOTIFIER
 	state_unregister_client(&notif);
-#else
-	fb_unregister_client(&notif);
 #endif
 	notif.notifier_call = NULL;
-	destroy_workqueue(susp_wq);
 	destroy_workqueue(hotplug_wq);
 
 	/* Put all sibling cores to sleep */
diff --git a/arch/arm/mach-msm/intelli_hotplug.c b/arch/arm/mach-msm/intelli_hotplug.c
index 32038b1..0201d86 100644
--- a/arch/arm/mach-msm/intelli_hotplug.c
+++ b/arch/arm/mach-msm/intelli_hotplug.c
@@ -20,8 +20,6 @@
 #include <linux/kobject.h>
 #ifdef CONFIG_STATE_NOTIFIER
 #include <linux/state_notifier.h>
-#else
-#include <linux/fb.h>
 #endif
 #include <linux/cpufreq.h>
 
@@ -39,7 +37,6 @@
 #define DEFAULT_MAX_CPUS_ONLINE		NR_CPUS
 #define DEFAULT_NR_FSHIFT		DEFAULT_MAX_CPUS_ONLINE - 1
 #define DEFAULT_DOWN_LOCK_DUR		2500
-#define DEFAULT_SUSPEND_DEFER_TIME	10
 #define DEFAULT_MAX_CPUS_ONLINE_SUSP	1
 
 #define CAPACITY_RESERVE		50
@@ -63,9 +60,6 @@ static u64 last_boost_time, last_input;
 static struct delayed_work intelli_plug_work;
 static struct work_struct up_down_work;
 static struct workqueue_struct *intelliplug_wq;
-static struct workqueue_struct *susp_wq;
-static struct delayed_work suspend_work;
-static struct work_struct resume_work;
 static struct mutex intelli_plug_mutex;
 static struct notifier_block notif;
 
@@ -83,7 +77,6 @@ static unsigned int full_mode_profile = 0;
 static unsigned int cpu_nr_run_threshold = CPU_NR_THRESHOLD;
 
 static bool hotplug_suspended = false;
-unsigned int suspend_defer_time = DEFAULT_SUSPEND_DEFER_TIME;
 static unsigned int min_cpus_online_res = DEFAULT_MIN_CPUS_ONLINE;
 static unsigned int max_cpus_online_res = DEFAULT_MAX_CPUS_ONLINE;
 static unsigned int max_cpus_online_susp = DEFAULT_MAX_CPUS_ONLINE_SUSP;
@@ -287,7 +280,7 @@ static void intelli_plug_work_fn(struct work_struct *work)
 					msecs_to_jiffies(def_sampling_ms));
 }
 
-static void intelli_plug_suspend(struct work_struct *work)
+static void intelli_plug_suspend(void)
 {
 	int cpu = 0;
 
@@ -316,7 +309,7 @@ static void intelli_plug_suspend(struct work_struct *work)
 	}
 }
 
-static void __ref intelli_plug_resume(struct work_struct *work)
+static void __ref intelli_plug_resume(void)
 {
 	int cpu, required_reschedule = 0, required_wakeup = 0;
 
@@ -351,37 +344,19 @@ static void __ref intelli_plug_resume(struct work_struct *work)
 				      msecs_to_jiffies(RESUME_SAMPLING_MS));
 }
 
-static void __intelli_plug_suspend(void)
-{
-	if ((atomic_read(&intelli_plug_active) == 0) ||
-		hotplug_suspended)
-		return;
-
-	INIT_DELAYED_WORK(&suspend_work, intelli_plug_suspend);
-	queue_delayed_work_on(0, susp_wq, &suspend_work, 
-				 msecs_to_jiffies(suspend_defer_time * 1000)); 
-}
-
-static void __intelli_plug_resume(void)
-{
-	if (atomic_read(&intelli_plug_active) == 0)
-		return;
-
-	flush_workqueue(susp_wq);
-	cancel_delayed_work_sync(&suspend_work);
-	queue_work_on(0, susp_wq, &resume_work);
-}
-
 #ifdef CONFIG_STATE_NOTIFIER
 static int state_notifier_callback(struct notifier_block *this,
 				unsigned long event, void *data)
 {
+	if (atomic_read(&intelli_plug_active) == 0)
+		return NOTIFY_OK;
+
 	switch (event) {
 		case STATE_NOTIFIER_ACTIVE:
-			__intelli_plug_resume();
+			intelli_plug_resume();
 			break;
 		case STATE_NOTIFIER_SUSPEND:
-			__intelli_plug_suspend();
+			intelli_plug_suspend();
 			break;
 		default:
 			break;
@@ -389,35 +364,6 @@ static int state_notifier_callback(struct notifier_block *this,
 
 	return NOTIFY_OK;
 }
-#else
-static int prev_fb = FB_BLANK_UNBLANK;
-
-static int fb_notifier_callback(struct notifier_block *self,
-				unsigned long event, void *data)
-{
-	struct fb_event *evdata = data;
-	int *blank;
-
-	if (evdata && evdata->data && event == FB_EVENT_BLANK) {
-		blank = evdata->data;
-		switch (*blank) {
-			case FB_BLANK_UNBLANK:
-				if (prev_fb == FB_BLANK_POWERDOWN) {
-					__intelli_plug_resume();
-					prev_fb = FB_BLANK_UNBLANK;
-				}
-				break;
-			case FB_BLANK_POWERDOWN:
-				if (prev_fb == FB_BLANK_UNBLANK) {
-					__intelli_plug_suspend();
-					prev_fb = FB_BLANK_POWERDOWN;
-				}
-				break;
-		}
-	}
-
-	return NOTIFY_OK;
-}
 #endif
 
 static void intelli_plug_input_event(struct input_handle *handle,
@@ -523,15 +469,6 @@ static int __ref intelli_plug_start(void)
 		goto err_out;
 	}
 
-	susp_wq =
-	    alloc_workqueue("intelli_susp_wq", WQ_FREEZABLE, 0);
-	if (!susp_wq) {
-		pr_err("%s: Failed to allocate suspend workqueue\n",
-		       INTELLI_PLUG);
-		ret = -ENOMEM;
-		goto err_out;
-	}
-
 #ifdef CONFIG_STATE_NOTIFIER
 	notif.notifier_call = state_notifier_callback;
 	if (state_register_client(&notif)) {
@@ -539,13 +476,6 @@ static int __ref intelli_plug_start(void)
 			INTELLI_PLUG);
 		goto err_dev;
 	}
-#else
-	notif.notifier_call = fb_notifier_callback;
-	if (fb_register_client(&notif)) {
-		pr_err("%s: Failed to register FB notifier callback\n",
-			INTELLI_PLUG);
-		goto err_dev;
-	}
 #endif
 
 	ret = input_register_handler(&intelli_plug_input_handler);
@@ -563,8 +493,6 @@ static int __ref intelli_plug_start(void)
 		dl = &per_cpu(lock_info, cpu);
 		INIT_DELAYED_WORK(&dl->lock_rem, remove_down_lock);
 	}
-	INIT_DELAYED_WORK(&suspend_work, intelli_plug_suspend);
-	INIT_WORK(&resume_work, intelli_plug_resume);
 
 	/* Fire up all CPUs */
 	for_each_cpu_not(cpu, cpu_online_mask) {
@@ -590,10 +518,6 @@ static void intelli_plug_stop(void)
 	int cpu;
 	struct down_lock *dl;
 
-	flush_workqueue(susp_wq);
-	cancel_work_sync(&resume_work);
-	cancel_delayed_work_sync(&suspend_work);
-
 	for_each_possible_cpu(cpu) {
 		dl = &per_cpu(lock_info, cpu);
 		cancel_delayed_work_sync(&dl->lock_rem);
@@ -604,13 +528,10 @@ static void intelli_plug_stop(void)
 	mutex_destroy(&intelli_plug_mutex);
 #ifdef CONFIG_STATE_NOTIFIER
 	state_unregister_client(&notif);
-#else
-	fb_unregister_client(&notif);
 #endif
 	notif.notifier_call = NULL;
 
 	input_unregister_handler(&intelli_plug_input_handler);
-	destroy_workqueue(susp_wq);
 	destroy_workqueue(intelliplug_wq);
 }
 
@@ -639,7 +560,6 @@ show_one(cpus_boosted, cpus_boosted);
 show_one(min_cpus_online, min_cpus_online);
 show_one(max_cpus_online, max_cpus_online);
 show_one(max_cpus_online_susp, max_cpus_online_susp);
-show_one(suspend_defer_time, suspend_defer_time);
 show_one(full_mode_profile, full_mode_profile);
 show_one(cpu_nr_run_threshold, cpu_nr_run_threshold);
 show_one(def_sampling_ms, def_sampling_ms);
@@ -667,7 +587,6 @@ static ssize_t store_##file_name		\
 }
 
 store_one(cpus_boosted, cpus_boosted);
-store_one(suspend_defer_time, suspend_defer_time);
 store_one(full_mode_profile, full_mode_profile);
 store_one(cpu_nr_run_threshold, cpu_nr_run_threshold);
 store_one(def_sampling_ms, def_sampling_ms);
@@ -794,7 +713,6 @@ KERNEL_ATTR_RW(cpus_boosted);
 KERNEL_ATTR_RW(min_cpus_online);
 KERNEL_ATTR_RW(max_cpus_online);
 KERNEL_ATTR_RW(max_cpus_online_susp);
-KERNEL_ATTR_RW(suspend_defer_time);
 KERNEL_ATTR_RW(full_mode_profile);
 KERNEL_ATTR_RW(cpu_nr_run_threshold);
 KERNEL_ATTR_RW(boost_lock_duration);
@@ -810,7 +728,6 @@ static struct attribute *intelli_plug_attrs[] = {
 	&min_cpus_online_attr.attr,
 	&max_cpus_online_attr.attr,
 	&max_cpus_online_susp_attr.attr,
-	&suspend_defer_time_attr.attr,
 	&full_mode_profile_attr.attr,
 	&cpu_nr_run_threshold_attr.attr,
 	&boost_lock_duration_attr.attr,
diff --git a/arch/arm/mach-msm/msm_hotplug.c b/arch/arm/mach-msm/msm_hotplug.c
index 64752c6..2746fc6 100644
--- a/arch/arm/mach-msm/msm_hotplug.c
+++ b/arch/arm/mach-msm/msm_hotplug.c
@@ -21,8 +21,6 @@
 #include <linux/cpufreq.h>
 #ifdef CONFIG_STATE_NOTIFIER
 #include <linux/state_notifier.h>
-#else
-#include <linux/fb.h>
 #endif
 #include <linux/mutex.h>
 #include <linux/input.h>
@@ -42,7 +40,6 @@
 #define DEFAULT_MIN_CPUS_ONLINE		1
 #define DEFAULT_MAX_CPUS_ONLINE		NR_CPUS
 #define DEFAULT_FAST_LANE_LOAD		99
-#define DEFAULT_SUSPEND_DEFER_TIME	10
 #define DEFAULT_MAX_CPUS_ONLINE_SUSP	1
 
 static unsigned int debug = 0;
@@ -57,7 +54,6 @@ do { 				\
 static struct cpu_hotplug {
 	unsigned int msm_enabled;
 	unsigned int suspended;
-	unsigned int suspend_defer_time;
 	unsigned int min_cpus_online_res;
 	unsigned int max_cpus_online_res;
 	unsigned int max_cpus_online_susp;
@@ -72,8 +68,6 @@ static struct cpu_hotplug {
 	unsigned int fast_lane_load;
 	struct work_struct up_work;
 	struct work_struct down_work;
-	struct delayed_work suspend_work;
-	struct work_struct resume_work;
 	struct mutex msm_hotplug_mutex;
 	struct notifier_block notif;
 } hotplug = {
@@ -81,7 +75,6 @@ static struct cpu_hotplug {
 	.min_cpus_online = DEFAULT_MIN_CPUS_ONLINE,
 	.max_cpus_online = DEFAULT_MAX_CPUS_ONLINE,
 	.suspended = 0,
-	.suspend_defer_time = DEFAULT_SUSPEND_DEFER_TIME,
 	.min_cpus_online_res = DEFAULT_MIN_CPUS_ONLINE,
 	.max_cpus_online_res = DEFAULT_MAX_CPUS_ONLINE,
 	.max_cpus_online_susp = DEFAULT_MAX_CPUS_ONLINE_SUSP,
@@ -92,7 +85,6 @@ static struct cpu_hotplug {
 };
 
 static struct workqueue_struct *hotplug_wq;
-static struct workqueue_struct *susp_wq;
 static struct delayed_work hotplug_work;
 
 static u64 last_boost_time;
@@ -474,7 +466,7 @@ static void msm_hotplug_work(struct work_struct *work)
 	reschedule_hotplug_work();
 }
 
-static void msm_hotplug_suspend(struct work_struct *work)
+static void msm_hotplug_suspend(void)
 {
 	int cpu;
 
@@ -502,7 +494,7 @@ static void msm_hotplug_suspend(struct work_struct *work)
 	}
 }
 
-static void __ref msm_hotplug_resume(struct work_struct *work)
+static void __ref msm_hotplug_resume(void)
 {
 	int cpu, required_reschedule = 0, required_wakeup = 0;
 
@@ -535,36 +527,19 @@ static void __ref msm_hotplug_resume(struct work_struct *work)
 		reschedule_hotplug_work();
 }
 
-static void __msm_hotplug_suspend(void)
-{
-	if (!hotplug.msm_enabled || hotplug.suspended)
-		return;
-
-	INIT_DELAYED_WORK(&hotplug.suspend_work, msm_hotplug_suspend);
-	queue_delayed_work_on(0, susp_wq, &hotplug.suspend_work, 
-				 msecs_to_jiffies(hotplug.suspend_defer_time * 1000)); 
-}
-
-static void __msm_hotplug_resume(void)
-{
-	if (!hotplug.msm_enabled)
-		return;
-
-	flush_workqueue(susp_wq);
-	cancel_delayed_work_sync(&hotplug.suspend_work);
-	queue_work_on(0, susp_wq, &hotplug.resume_work);
-}
-
 #ifdef CONFIG_STATE_NOTIFIER
 static int state_notifier_callback(struct notifier_block *this,
 				unsigned long event, void *data)
 {
+	if (!hotplug.msm_enabled)
+		return NOTIFY_OK;
+
 	switch (event) {
 		case STATE_NOTIFIER_ACTIVE:
-			__msm_hotplug_resume();
+			msm_hotplug_resume();
 			break;
 		case STATE_NOTIFIER_SUSPEND:
-			__msm_hotplug_suspend();
+			msm_hotplug_suspend();
 			break;
 		default:
 			break;
@@ -572,35 +547,6 @@ static int state_notifier_callback(struct notifier_block *this,
 
 	return NOTIFY_OK;
 }
-#else
-static int prev_fb = FB_BLANK_UNBLANK;
-
-static int fb_notifier_callback(struct notifier_block *self,
-				unsigned long event, void *data)
-{
-	struct fb_event *evdata = data;
-	int *blank;
-
-	if (evdata && evdata->data && event == FB_EVENT_BLANK) {
-		blank = evdata->data;
-		switch (*blank) {
-			case FB_BLANK_UNBLANK:
-				if (prev_fb == FB_BLANK_POWERDOWN) {
-					__msm_hotplug_resume();
-					prev_fb = FB_BLANK_UNBLANK;
-				}
-				break;
-			case FB_BLANK_POWERDOWN:
-				if (prev_fb == FB_BLANK_UNBLANK) {
-					__msm_hotplug_suspend();
-					prev_fb = FB_BLANK_POWERDOWN;
-				}
-				break;
-		}
-	}
-
-	return NOTIFY_OK;
-}
 #endif
 
 static void hotplug_input_event(struct input_handle *handle, unsigned int type,
@@ -708,15 +654,6 @@ static int __ref msm_hotplug_start(void)
 		goto err_out;
 	}
 
-	susp_wq =
-	    alloc_workqueue("susp_wq", WQ_FREEZABLE, 0);
-	if (!susp_wq) {
-		pr_err("%s: Failed to allocate suspend workqueue\n",
-		       MSM_HOTPLUG);
-		ret = -ENOMEM;
-		goto err_out;
-	}
-
 #ifdef CONFIG_STATE_NOTIFIER
 	hotplug.notif.notifier_call = state_notifier_callback;
 	if (state_register_client(&hotplug.notif)) {
@@ -724,13 +661,6 @@ static int __ref msm_hotplug_start(void)
 			MSM_HOTPLUG);
 		goto err_dev;
 	}
-#else
-	hotplug.notif.notifier_call = fb_notifier_callback;
-	if (fb_register_client(&hotplug.notif)) {
-		pr_err("%s: Failed to register FB notifier callback\n",
-			MSM_HOTPLUG);
-		goto err_dev;
-	}
 #endif
 
 	ret = input_register_handler(&hotplug_input_handler);
@@ -757,8 +687,6 @@ static int __ref msm_hotplug_start(void)
 		dl = &per_cpu(lock_info, cpu);
 		INIT_DELAYED_WORK(&dl->lock_rem, remove_down_lock);
 	}
-	INIT_DELAYED_WORK(&hotplug.suspend_work, msm_hotplug_suspend);
-	INIT_WORK(&hotplug.resume_work, msm_hotplug_resume);
 
 	/* Fire up all CPUs */
 	for_each_cpu_not(cpu, cpu_online_mask) {
@@ -784,9 +712,6 @@ static void msm_hotplug_stop(void)
 	int cpu;
 	struct down_lock *dl;
 
-	flush_workqueue(susp_wq);
-	cancel_work_sync(&hotplug.resume_work);
-	cancel_delayed_work_sync(&hotplug.suspend_work);
 	flush_workqueue(hotplug_wq);
 	for_each_possible_cpu(cpu) {
 		dl = &per_cpu(lock_info, cpu);
@@ -802,13 +727,10 @@ static void msm_hotplug_stop(void)
 
 #ifdef CONFIG_STATE_NOTIFIER
 	state_unregister_client(&hotplug.notif);
-#else
-	fb_unregister_client(&hotplug.notif);
 #endif
 	hotplug.notif.notifier_call = NULL;
 	input_unregister_handler(&hotplug_input_handler);
 
-	destroy_workqueue(susp_wq);
 	destroy_workqueue(hotplug_wq);
 
 	/* Put all sibling cores to sleep */
@@ -1104,29 +1026,6 @@ static ssize_t store_max_cpus_online(struct device *dev,
 	return count;
 }
 
-static ssize_t store_suspend_defer_time(struct device *dev,
-				    struct device_attribute *msm_hotplug_attrs,
-				    const char *buf, size_t count)
-{
-	int ret;
-	unsigned int val;
-
-	ret = sscanf(buf, "%u", &val);
-	if (ret != 1)
-		return -EINVAL;
-
-	hotplug.suspend_defer_time = val;
-
-	return count;
-}
-
-static ssize_t show_suspend_defer_time(struct device *dev,
-				 struct device_attribute *msm_hotplug_attrs,
-				 char *buf)
-{
-	return sprintf(buf, "%u\n", hotplug.suspend_defer_time);
-}
-
 static ssize_t show_max_cpus_online_susp(struct device *dev,
 				    struct device_attribute *msm_hotplug_attrs,
 				    char *buf)
@@ -1261,8 +1160,6 @@ static DEVICE_ATTR(min_cpus_online, 644, show_min_cpus_online,
 		   store_min_cpus_online);
 static DEVICE_ATTR(max_cpus_online, 644, show_max_cpus_online,
 		   store_max_cpus_online);
-static DEVICE_ATTR(suspend_defer_time, 644, show_suspend_defer_time,
-		   store_suspend_defer_time);
 static DEVICE_ATTR(max_cpus_online_susp, 644, show_max_cpus_online_susp,
 		   store_max_cpus_online_susp);
 static DEVICE_ATTR(cpus_boosted, 644, show_cpus_boosted, store_cpus_boosted);
@@ -1281,7 +1178,6 @@ static struct attribute *msm_hotplug_attrs[] = {
 	&dev_attr_history_size.attr,
 	&dev_attr_min_cpus_online.attr,
 	&dev_attr_max_cpus_online.attr,
-	&dev_attr_suspend_defer_time.attr,
 	&dev_attr_max_cpus_online_susp.attr,
 	&dev_attr_cpus_boosted.attr,
 	&dev_attr_offline_load.attr,
