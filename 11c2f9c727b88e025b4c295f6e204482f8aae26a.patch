From 11c2f9c727b88e025b4c295f6e204482f8aae26a Mon Sep 17 00:00:00 2001
From: dorimanx <yuri@bynet.co.il>
Date: Mon, 2 Jun 2014 22:46:12 +0300
Subject: [PATCH] Tune All BLOCK govs for Android needs, and allow more write
 power in ROW.

---
 block/bfq-iosched.c      | 10 +++++-----
 block/cfq-iosched.c      | 18 +++++++++---------
 block/deadline-iosched.c |  6 +++---
 block/row-iosched.c      |  8 ++++----
 block/sio-iosched.c      | 10 +++++-----
 5 files changed, 26 insertions(+), 26 deletions(-)

diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index f5bd73d..e90d4d2 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -70,7 +70,7 @@
 static const int bfq_quantum = 4;
 
 /* Expiration time of sync (0) and async (1) requests, in jiffies. */
-static const int bfq_fifo_expire[2] = { HZ / 4, HZ / 8 };
+static const int bfq_fifo_expire[2] = { 100 / 4, 100 / 8 };
 
 /* Maximum backwards seek, in KiB. */
 static const int bfq_back_max = 16 * 1024;
@@ -79,7 +79,7 @@ static const int bfq_back_max = 16 * 1024;
 static const int bfq_back_penalty = 2;
 
 /* Idling period duration, in jiffies. */
-static int bfq_slice_idle = HZ / 125;
+static int bfq_slice_idle = 100 / 125;
 
 /* Default maximum budget values, in sectors and number of requests. */
 static const int bfq_default_max_budget = 16 * 1024;
@@ -93,8 +93,8 @@ static const int bfq_max_budget_async_rq = 4;
 static const int bfq_async_charge_factor = 10;
 
 /* Default timeout values, in jiffies, approximating CFQ defaults. */
-static const int bfq_timeout_sync = HZ / 8;
-static int bfq_timeout_async = HZ / 25;
+static const int bfq_timeout_sync = 100 / 8;
+static int bfq_timeout_async = 100 / 25;
 
 struct kmem_cache *bfq_pool;
 
@@ -1874,7 +1874,7 @@ static inline unsigned long bfq_bfqq_softrt_next_start(struct bfq_data *bfqd,
 						       struct bfq_queue *bfqq)
 {
 	return max(bfqq->last_idle_bklogged +
-		   HZ * bfqq->service_from_backlogged /
+		   100 * bfqq->service_from_backlogged /
 		   bfqd->bfq_wr_max_softrt_rate,
 		   jiffies + bfqq->bfqd->bfq_slice_idle + 4);
 }
diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index b9083d0..374f10b 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -22,23 +22,23 @@
  */
 /* max queue in one round of service */
 static const int cfq_quantum = 8;
-static const int cfq_fifo_expire[2] = { HZ / 4, HZ / 8 };
+static const int cfq_fifo_expire[2] = { 100 / 4, 100 / 8 };
 /* maximum backwards seek, in KiB */
 static const int cfq_back_max = 16 * 1024;
 /* penalty of a backwards seek */
 static const int cfq_back_penalty = 2;
-static const int cfq_slice_sync = HZ / 10;
-static int cfq_slice_async = HZ / 25;
+static const int cfq_slice_sync = 100 / 10;
+static int cfq_slice_async = 100 / 25;
 static const int cfq_slice_async_rq = 2;
-static int cfq_slice_idle = HZ / 125;
-static int cfq_group_idle = HZ / 125;
-static const int cfq_target_latency = HZ * 3/10; /* 300 ms */
+static int cfq_slice_idle = 100 / 125;
+static int cfq_group_idle = 100 / 125;
+static const int cfq_target_latency = 100 * 3/10; /* 300 ms */
 static const int cfq_hist_divisor = 4;
 
 /*
  * offset from end of service tree
  */
-#define CFQ_IDLE_DELAY		(HZ / 5)
+#define CFQ_IDLE_DELAY		(100 / 5)
 
 /*
  * below this threshold, we consider thinktime immediate
@@ -1326,7 +1326,7 @@ static void cfq_service_tree_add(struct cfq_data *cfqd, struct cfq_queue *cfqq,
 		rb_key -= cfqq->slice_resid;
 		cfqq->slice_resid = 0;
 	} else {
-		rb_key = -HZ;
+		rb_key = -100;
 		__cfqq = cfq_rb_first(service_tree);
 		rb_key += __cfqq ? __cfqq->rb_key : jiffies;
 	}
@@ -3873,7 +3873,7 @@ static void *cfq_init_queue(struct request_queue *q)
 	 * we optimistically start assuming sync ops weren't delayed in last
 	 * second, in order to have larger depth for async operations.
 	 */
-	cfqd->last_delayed_sync = jiffies - HZ;
+	cfqd->last_delayed_sync = jiffies - 100;
 	return cfqd;
 }
 
diff --git a/block/deadline-iosched.c b/block/deadline-iosched.c
index 3f40c3f..fe9f339 100644
--- a/block/deadline-iosched.c
+++ b/block/deadline-iosched.c
@@ -17,10 +17,10 @@
 /*
  * See Documentation/block/deadline-iosched.txt
  */
-static const int read_expire = HZ / 4;  /* max time before a read is submitted. */
-static const int write_expire = 2 * HZ; /* ditto for writes, these limits are SOFT! */
+static const int read_expire = 100 / 4;  /* max time before a read is submitted. */
+static const int write_expire = 2 * 100; /* ditto for writes, these limits are SOFT! */
 static const int writes_starved = 1;    /* max times reads can starve a write */
-static const int fifo_batch = 8;       /* # of sequential requests treated as one
+static const int fifo_batch = 1;       /* # of sequential requests treated as one
 				     by the above parameters. For throughput. */
 
 struct deadline_data {
diff --git a/block/row-iosched.c b/block/row-iosched.c
index dfb46b4..6fd2539 100644
--- a/block/row-iosched.c
+++ b/block/row-iosched.c
@@ -87,11 +87,11 @@ struct row_queue_params {
 static const struct row_queue_params row_queues_def[] = {
 /* idling_enabled, quantum, is_urgent */
 	{true, 10, true},	/* ROWQ_PRIO_HIGH_READ */
-	{false, 1, false},	/* ROWQ_PRIO_HIGH_SWRITE */
-	{true, 100, true},	/* ROWQ_PRIO_REG_READ */
+	{false, 5, true},	/* ROWQ_PRIO_HIGH_SWRITE */
+	{true, 80, true},	/* ROWQ_PRIO_REG_READ */
 	{false, 1, false},	/* ROWQ_PRIO_REG_SWRITE */
-	{false, 1, false},	/* ROWQ_PRIO_REG_WRITE */
-	{false, 1, false},	/* ROWQ_PRIO_LOW_READ */
+	{false, 20, true},	/* ROWQ_PRIO_REG_WRITE */
+	{false, 5, false},	/* ROWQ_PRIO_LOW_READ */
 	{false, 1, false}	/* ROWQ_PRIO_LOW_SWRITE */
 };
 
diff --git a/block/sio-iosched.c b/block/sio-iosched.c
index eb319ba..4f111b5 100644
--- a/block/sio-iosched.c
+++ b/block/sio-iosched.c
@@ -23,14 +23,14 @@
 enum { ASYNC, SYNC };
 
 /* Tunables */
-static const int sync_read_expire  = HZ / 2;	/* max time before a sync read is submitted. */
-static const int sync_write_expire = 2 * HZ;	/* max time before a sync write is submitted. */
+static const int sync_read_expire  = 100 / 2;	/* max time before a sync read is submitted. */
+static const int sync_write_expire = 2 * 100;	/* max time before a sync write is submitted. */
 
-static const int async_read_expire  =  4 * HZ;	/* ditto for async, these limits are SOFT! */
-static const int async_write_expire = 16 * HZ;	/* ditto for async, these limits are SOFT! */
+static const int async_read_expire  =  4 * 100;	/* ditto for async, these limits are SOFT! */
+static const int async_write_expire = 16 * 100;	/* ditto for async, these limits are SOFT! */
 
 static const int writes_starved = 2;		/* max times reads can starve a write */
-static const int fifo_batch     = 8;		/* # of sequential requests treated as one
+static const int fifo_batch     = 1;		/* # of sequential requests treated as one
 						   by the above parameters. For throughput. */
 
 /* Elevator data */
