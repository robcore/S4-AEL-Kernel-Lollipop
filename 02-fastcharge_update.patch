From b18f42bb79ff3075866a6665fb3761cd9637c90e Mon Sep 17 00:00:00 2001
From: Tkkg1994 <luca.grifo@outlook.com>
Date: Sun, 15 Mar 2015 19:45:21 +0100
Subject: [PATCH] drivers: battery: fixed fastchg values thanks to googy and
 ktoonsez

---
 arch/arm/mach-msm/board-fusion3-battery.c |  10 +--
 arch/arm/mach-msm/fastchg.c               | 104 ++++++++++++++++++++++++++++--
 drivers/battery/max77693_charger.c        |  21 +++++-
 drivers/usb/otg/msm_otg.c                 |   8 +++
 include/linux/fastchg.h                   |  29 ++++++---
 5 files changed, 150 insertions(+), 22 deletions(-)

diff --git a/arch/arm/mach-msm/board-fusion3-battery.c b/arch/arm/mach-msm/board-fusion3-battery.c
index fd142cd..c6c4040 100755
--- a/arch/arm/mach-msm/board-fusion3-battery.c
+++ b/arch/arm/mach-msm/board-fusion3-battery.c
@@ -358,13 +358,13 @@ static int sec_bat_get_cable_from_extended_cable_type(
 	if (force_fast_charge == FAST_CHARGE_FORCE_AC) {
 		switch(cable_type) {
 			/* These are low current USB connections,
-			   apply normal 0.9A AC levels to USB */
+			   apply normal 1A AC levels to USB */
 			case POWER_SUPPLY_TYPE_USB:
 			case POWER_SUPPLY_TYPE_USB_ACA:
 			case POWER_SUPPLY_TYPE_CARDOCK:
 			case POWER_SUPPLY_TYPE_OTG:
-				charge_current_max = USB_CHARGE_900;
-				charge_current     = USB_CHARGE_900;
+				charge_current_max = USB_CHARGE_1000;
+				charge_current     = USB_CHARGE_1000;
 				break;
 
 		}
@@ -387,7 +387,7 @@ static int sec_bat_get_cable_from_extended_cable_type(
 			   for all of them */
 			case POWER_SUPPLY_TYPE_MAINS:
 				charge_current_max = ac_charge_level;
-				/* but never go above 1.6A */
+				/* but never go above 1.9A */
 				charge_current     =
 					min(ac_charge_level, MAX_CHARGE_LEVEL);
 				break;
@@ -810,7 +810,7 @@ sec_battery_platform_data_t sec_battery_pdata = {
 	.temp_low_threshold_normal = -30,
 	.temp_low_recovery_normal = 0,
 
-	.temp_high_threshold_lpm = 470,
+	.temp_high_threshold_lpm = 500,
 	.temp_high_recovery_lpm = 430,
 	.temp_low_threshold_lpm = -30,
 	.temp_low_recovery_lpm = 0,
diff --git a/arch/arm/mach-msm/fastchg.c b/arch/arm/mach-msm/fastchg.c
index 8ee8d2e..77b468a 100755
--- a/arch/arm/mach-msm/fastchg.c
+++ b/arch/arm/mach-msm/fastchg.c
@@ -5,6 +5,8 @@
  * Adapted for 9505 from Note 3:
  * Paul Reioux <reioux@gmail.com>
  *
+ * Modded by ktoonsez from Jean-Pierre and Faux's original implementation:
+ *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
  * may be copied, distributed, and modified under those terms.
@@ -26,6 +28,16 @@
  *   1 - substitute AC to USB
  *   2 - use custom mA configured through sysfs interface (see below)
  *
+ * /sys/kernel/fast_charge/use_mtp_during_fast_charge (rw)
+ *
+ *   0 - disabled
+ *   1 - enabled (default)
+ *
+ * /sys/kernel/fast_charge/screen_on_current_limit (rw)
+ *
+ *   0 - disabled
+ *   1 - enabled (default)
+ *
  * /sys/kernel/fast_charge/ac_charge_level (rw)
  *
  *   rate at which to charge when on AC (1.0A/h to 2.1A/h)
@@ -39,7 +51,7 @@
  *   0 - disabled - allow anything up to 2.1A/h to be used as AC / USB custom current
  *   1 - enabled  - behaviour as described above (default)
  *
- * /sys/kernel/fast_charge/ac_leves (ro)
+ * /sys/kernel/fast_charge/ac_levels (ro)
  *
  *   display available levels for AC (for failsafe enabled mode)
  *
@@ -95,6 +107,71 @@ static struct kobj_attribute force_fast_charge_attribute =
 		force_fast_charge_show,
 		force_fast_charge_store);
 
+int use_mtp_during_fast_charge;
+
+/* sysfs interface for "use_mtp_during_fast_charge" */
+static ssize_t use_mtp_during_fast_charge_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", use_mtp_during_fast_charge);
+}
+
+static ssize_t use_mtp_during_fast_charge_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+
+	int new_use_mtp_during_fast_charge;
+
+	sscanf(buf, "%du", &new_use_mtp_during_fast_charge);
+
+	switch(new_use_mtp_during_fast_charge) {
+		case USE_MTP_DURING_FAST_CHARGE_DISABLED:
+		case USE_MTP_DURING_FAST_CHARGE_ENABLED:
+			use_mtp_during_fast_charge = new_use_mtp_during_fast_charge;
+			return count;
+		default:
+			return -EINVAL;
+	}
+}
+
+static struct kobj_attribute use_mtp_during_fast_charge_attribute =
+	__ATTR(use_mtp_during_fast_charge, 0666,
+		use_mtp_during_fast_charge_show,
+		use_mtp_during_fast_charge_store);
+
+int screen_on_current_limit;
+
+/* sysfs interface for "screen_on_current_limit" */
+static ssize_t screen_on_current_limit_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", screen_on_current_limit);
+}
+
+static ssize_t screen_on_current_limit_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+
+	int new_screen_on_current_limit;
+
+	sscanf(buf, "%du", &new_screen_on_current_limit);
+
+	switch(new_screen_on_current_limit) {
+		case SCREEN_ON_CURRENT_LIMIT_DISABLED:
+		case SCREEN_ON_CURRENT_LIMIT_ENABLED:
+			screen_on_current_limit = new_screen_on_current_limit;
+			return count;
+		default:
+			return -EINVAL;
+	}
+}
+
+static struct kobj_attribute screen_on_current_limit_attribute =
+	__ATTR(screen_on_current_limit, 0666,
+		screen_on_current_limit_show,
+		screen_on_current_limit_store);
+
+
 /* sysfs interface for "ac_charge_level" */
 
 int ac_charge_level;
@@ -124,9 +201,10 @@ static ssize_t ac_charge_level_store(struct kobject *kobj,
 	else {
 
 		switch (new_ac_charge_level) {
+			case AC_CHARGE_500:
 			case AC_CHARGE_1000:
-			case AC_CHARGE_1300:
-			case AC_CHARGE_1600:
+			case AC_CHARGE_1450:
+			case AC_CHARGE_1900:
 				ac_charge_level = new_ac_charge_level;
 				return count;
 			default:
@@ -176,7 +254,7 @@ static ssize_t usb_charge_level_store(struct kobject *kobj,
 		switch (new_usb_charge_level) {
 			case USB_CHARGE_460:
 			case USB_CHARGE_700:
-			case USB_CHARGE_900:
+			case USB_CHARGE_1000:
 				usb_charge_level = new_usb_charge_level;
 				return count;
 			default:
@@ -256,8 +334,10 @@ static ssize_t info_show(struct kobject *kobj,
 {
 	return sprintf(
 		buf,
-		"Forced Fast Charge for Samsung Note 3 %s\n\n"
+		"Forced Fast Charge for Samsung Galaxy S4 Qualcomm %s\n\n"
 		"Fast charge mode : %s\n"
+		"MTP while charging mode : %s\n"
+		"Screen on Current Limit mode : %s\n"
 		"Custom  AC level : %dmA/h\n"
 		"Custom USB level : %dmA/h\n"
 		"Failsafe mode    : %s\n"
@@ -267,6 +347,10 @@ static ssize_t info_show(struct kobject *kobj,
 		 force_fast_charge == FAST_CHARGE_DISABLED 	   ? "0 - Disabled (default)" :
 		(force_fast_charge == FAST_CHARGE_FORCE_AC         ? "1 - Use stock AC level on USB" :
 		(force_fast_charge == FAST_CHARGE_FORCE_CUSTOM_MA  ? "2 - Use custom mA on AC and USB" : "Problem : value out of range")),
+		 use_mtp_during_fast_charge          == USE_MTP_DURING_FAST_CHARGE_DISABLED           ? "0 - Disabled" :
+		(use_mtp_during_fast_charge          == USE_MTP_DURING_FAST_CHARGE_ENABLED            ? "1 - Enabled" : "Problem : value out of range"),
+		 screen_on_current_limit          == SCREEN_ON_CURRENT_LIMIT_DISABLED           ? "0 - Disabled" :
+		(screen_on_current_limit          == SCREEN_ON_CURRENT_LIMIT_ENABLED            ? "1 - Enabled" : "Problem : value out of range"),
 		 ac_charge_level,
 		 usb_charge_level,
 		 failsafe          == FAIL_SAFE_DISABLED           ? "0 - Failsafe disabled - please be careful !" :
@@ -294,6 +378,8 @@ static struct kobject *force_fast_charge_kobj;
 
 static struct attribute *force_fast_charge_attrs[] = {
 	&force_fast_charge_attribute.attr,
+	&use_mtp_during_fast_charge_attribute.attr,
+	&screen_on_current_limit_attribute.attr,
 	&ac_charge_level_attribute.attr,
 	&usb_charge_level_attribute.attr,
 	&failsafe_attribute.attr,
@@ -314,8 +400,12 @@ int force_fast_charge_init(void)
 
 	/* Forced fast charge disabled by default */
 	force_fast_charge = FAST_CHARGE_DISABLED;
-	/* Default AC charge level to 1000mA/h    */
-	ac_charge_level   = AC_CHARGE_1000;
+	/* Use MTP during fast charge, enabled by default */
+	use_mtp_during_fast_charge = USE_MTP_DURING_FAST_CHARGE_ENABLED;
+	/* Use Samsung Screen ON current limit while charging, enabled by default */
+	screen_on_current_limit = SCREEN_ON_CURRENT_LIMIT_ENABLED;
+	/* Default AC charge level to 1900mA/h    */
+	ac_charge_level   = AC_CHARGE_1900;
 	/* Default USB charge level to 460mA/h    */
 	usb_charge_level  = USB_CHARGE_460;
 	/* Allow only values in list by default   */
diff --git a/drivers/battery/max77693_charger.c b/drivers/battery/max77693_charger.c
index da731a6..49fb77d 100755
--- a/drivers/battery/max77693_charger.c
+++ b/drivers/battery/max77693_charger.c
@@ -15,6 +15,9 @@
 #ifdef CONFIG_USB_HOST_NOTIFY
 #include "../../arch/arm/mach-msm/board-8064.h"
 #endif
+#ifdef CONFIG_FORCE_FAST_CHARGE
+#include <linux/fastchg.h>
+#else
 
 #define ENABLE 1
 #define DISABLE 0
@@ -473,7 +476,11 @@ static void max77693_recovery_work(struct work_struct *work)
 		(chgin_dtls == 0x3) && (chg_dtls != 0x8) && (byp_dtls == 0x0))) {
 		pr_info("%s: try to recovery, cnt(%d)\n", __func__,
 				(chg_data->soft_reg_recovery_cnt + 1));
+#ifdef CONFIG_FORCE_FAST_CHARGE
+		if (screen_on_current_limit && chg_data->siop_level < 100 &&
+#else
 		if (chg_data->siop_level < 100 &&
+#endif
 				chg_data->cable_type == POWER_SUPPLY_TYPE_MAINS) {
 			pr_info("%s : LCD on status and revocer current\n", __func__);
 			max77693_set_input_current(chg_data,
@@ -822,8 +829,11 @@ static int sec_chg_set_property(struct power_supply *psy,
 			else
 				set_charging_current_max =
 					charger->charging_current_max;
-
+#ifdef CONFIG_FORCE_FAST_CHARGE
+			if (screen_on_current_limit && charger->siop_level < 100 &&
+#else
 			if (charger->siop_level < 100 &&
+#endif
 					val->intval == POWER_SUPPLY_TYPE_MAINS) {
 				set_charging_current_max = SIOP_INPUT_LIMIT_CURRENT;
 				if (set_charging_current > SIOP_CHARGING_LIMIT_CURRENT)
@@ -873,14 +883,21 @@ static int sec_chg_set_property(struct power_supply *psy,
 
 			/* do forced set charging current */
 			if (charger->cable_type == POWER_SUPPLY_TYPE_MAINS) {
+#ifdef CONFIG_FORCE_FAST_CHARGE
+				if (screen_on_current_limit && charger->siop_level < 100 )
+#else
 				if (charger->siop_level < 100 )
+#endif
 					set_charging_current_max =
 						SIOP_INPUT_LIMIT_CURRENT;
 				else
 					set_charging_current_max =
 						charger->charging_current_max;
-
+#ifdef CONFIG_FORCE_FAST_CHARGE
+				if (screen_on_current_limit && charger->siop_level < 100 && current_now > SIOP_CHARGING_LIMIT_CURRENT)
+#else
 				if (charger->siop_level < 100 && current_now > SIOP_CHARGING_LIMIT_CURRENT)
+#endif
 					current_now = SIOP_CHARGING_LIMIT_CURRENT;
 				max77693_set_input_current(charger,
 						set_charging_current_max);
diff --git a/drivers/usb/otg/msm_otg.c b/drivers/usb/otg/msm_otg.c
index 82fb027..b6b2a76 100755
--- a/drivers/usb/otg/msm_otg.c
+++ b/drivers/usb/otg/msm_otg.c
@@ -51,6 +51,9 @@
 #include <mach/msm_xo.h>
 #include <mach/msm_bus.h>
 #include <mach/rpm-regulator.h>
+#ifdef CONFIG_FORCE_FAST_CHARGE
+#include <linux/fastchg.h>
+#endif
 
 #define MSM_USB_BASE	(motg->regs)
 #define DRIVER_NAME	"msm_otg"
@@ -1595,6 +1598,11 @@ static void msm_otg_start_peripheral(struct usb_otg *otg, int on)
 	struct msm_otg *motg = container_of(otg->phy, struct msm_otg, phy);
 	struct msm_otg_platform_data *pdata = motg->pdata;
 
+#ifdef CONFIG_FORCE_FAST_CHARGE
+	if (!use_mtp_during_fast_charge && on == 1)
+		on = 0;
+#endif
+
 	if (!otg->gadget)
 		return;
 
diff --git a/include/linux/fastchg.h b/include/linux/fastchg.h
index 9ec3214..26fc7ee 100755
--- a/include/linux/fastchg.h
+++ b/include/linux/fastchg.h
@@ -5,6 +5,8 @@
  * Adapted for 9505 from Note 3:
  * Paul Reioux <reioux@gmail.com>
  *
+ * Modded by ktoonsez from Jean-Pierre and Faux's original implementation:
+ *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
  * may be copied, distributed, and modified under those terms.
@@ -20,10 +22,10 @@
 #ifndef _LINUX_FASTCHG_H
 #define _LINUX_FASTCHG_H
 
-#define FAST_CHARGE_VERSION "v1.0 by Paul Reioux"
-#define AC_LEVELS  "1000 1300 1600"
-#define USB_LEVELS "460 700 900"
-#define ANY_LEVELS "0 to 1600"
+#define FAST_CHARGE_VERSION "v1.1 by Ktoonsez from Jean-Pierre and Paul Reioux original implementation"
+#define AC_LEVELS  "500 1000 1450 1900"
+#define USB_LEVELS "460 700 1000"
+#define ANY_LEVELS "0 to 1900"
 
 extern int force_fast_charge;
 
@@ -31,20 +33,31 @@ extern int force_fast_charge;
 #define FAST_CHARGE_FORCE_AC 1
 #define FAST_CHARGE_FORCE_CUSTOM_MA 2
 
+extern int use_mtp_during_fast_charge;
+
+#define USE_MTP_DURING_FAST_CHARGE_DISABLED 0
+#define USE_MTP_DURING_FAST_CHARGE_ENABLED 1	/* default */
+
+extern int screen_on_current_limit;
+
+#define SCREEN_ON_CURRENT_LIMIT_DISABLED 0
+#define SCREEN_ON_CURRENT_LIMIT_ENABLED 1	/* default */
+
 extern int ac_charge_level;
 
+#define AC_CHARGE_500 500
 #define AC_CHARGE_1000 1000
-#define AC_CHARGE_1300 1300
-#define AC_CHARGE_1600 1600
+#define AC_CHARGE_1450 1300
+#define AC_CHARGE_1900 1900
 
 extern int usb_charge_level;
 
 #define USB_CHARGE_460 460	/* default */
 #define USB_CHARGE_700 700
-#define USB_CHARGE_900 900
+#define USB_CHARGE_1000 1000
 
 /* Whatever happens, this is the limit */
-#define MAX_CHARGE_LEVEL 1700
+#define MAX_CHARGE_LEVEL 1900
 
 extern int failsafe;
 #define FAIL_SAFE_ENABLED 1	/* default */
