From 2e93dcc6bb2be37527ab6d68d01423e4e63d80e8 Mon Sep 17 00:00:00 2001
From: Tkkg1994 <luca.grifo@outlook.com>
Date: Tue, 24 Mar 2015 17:35:57 +0100
Subject: [PATCH]  msm: thermal: Add IOCTL interface support to Kernel Thermal
 Monitor

Kernel Thermal Monitor exposes an IOCTL dev interface, which can
be used for user space cpu frequency mitigation.

CRs-Fixed: 538981
Change-Id: I48ab6be5a9bebee5219c94bdff81badf09576b2a
Signed-off-by: Ram Chandrasekar <rkumbako@codeaurora.org>
---
 drivers/thermal/Makefile          |   2 +-
 drivers/thermal/msm_thermal-dev.c | 224 ++++++++++++++++++++++++++++++++++++++
 include/linux/Kbuild              |   1 +
 include/linux/msm_thermal.h       |   8 ++
 include/linux/msm_thermal_ioctl.h |  41 +++++++
 5 files changed, 275 insertions(+), 1 deletion(-)
 create mode 100755 drivers/thermal/msm_thermal-dev.c
 create mode 100755 include/linux/msm_thermal_ioctl.h

diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index b0e1cbd..4139ce0 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -7,7 +7,7 @@ obj-$(CONFIG_THERMAL_MSM_POPMEM)	+= msm_popmem-tm.o
 obj-$(CONFIG_THERMAL_TSENS)	+= msm_tsens.o
 obj-$(CONFIG_THERMAL_TSENS8960) += msm8960_tsens.o
 obj-$(CONFIG_THERMAL_PM8XXX)	+= pm8xxx-tm.o
-obj-$(CONFIG_THERMAL_MONITOR)	+= msm_thermal.o
+obj-$(CONFIG_THERMAL_MONITOR)	+= msm_thermal.o msm_thermal-dev.o
 obj-$(CONFIG_INTELLI_THERMAL)	+= intelli/msm_thermal.o
 obj-$(CONFIG_SPEAR_THERMAL)	+= spear_thermal.o
 obj-$(CONFIG_THERMAL_TSENS8974)	+= msm8974-tsens.o
diff --git a/drivers/thermal/msm_thermal-dev.c b/drivers/thermal/msm_thermal-dev.c
new file mode 100755
index 0000000..c34dd27
--- /dev/null
+++ b/drivers/thermal/msm_thermal-dev.c
@@ -0,0 +1,224 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/msm_thermal_ioctl.h>
+#include <linux/msm_thermal.h>
+#include <linux/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/semaphore.h>
+#include <linux/module.h>
+
+struct msm_thermal_ioctl_dev {
+	struct semaphore sem;
+	struct cdev char_dev;
+};
+
+static int msm_thermal_major;
+static struct class *thermal_class;
+static struct msm_thermal_ioctl_dev *msm_thermal_dev;
+
+static int msm_thermal_ioctl_open(struct inode *node, struct file *filep)
+{
+	int ret = 0;
+	struct msm_thermal_ioctl_dev *dev;
+
+	dev = container_of(node->i_cdev, struct msm_thermal_ioctl_dev,
+		char_dev);
+	filep->private_data = dev;
+
+	return ret;
+}
+
+static int msm_thermal_ioctl_release(struct inode *node, struct file *filep)
+{
+	pr_debug("%s: IOCTL: release\n", KBUILD_MODNAME);
+	return 0;
+}
+
+static long validate_and_copy(unsigned int *cmd, unsigned long *arg,
+	struct msm_thermal_ioctl *query)
+{
+	long ret = 0, err_val = 0;
+
+	if ((_IOC_TYPE(*cmd) != MSM_THERMAL_MAGIC_NUM) ||
+		(_IOC_NR(*cmd) >= MSM_CMD_MAX_NR)) {
+		ret = -ENOTTY;
+		goto validate_exit;
+	}
+
+	if (_IOC_DIR(*cmd) & _IOC_READ) {
+		err_val = !access_ok(VERIFY_WRITE, (void __user *)*arg,
+				_IOC_SIZE(*cmd));
+	} else if (_IOC_DIR(*cmd) & _IOC_WRITE) {
+		err_val = !access_ok(VERIFY_READ, (void __user *)*arg,
+				_IOC_SIZE(*cmd));
+	}
+	if (err_val) {
+		ret = -EFAULT;
+		goto validate_exit;
+	}
+
+	if (copy_from_user(query, (void __user *)(*arg),
+		sizeof(struct msm_thermal_ioctl))) {
+		ret = -EACCES;
+		goto validate_exit;
+	}
+
+	if (query->size != sizeof(struct msm_thermal_ioctl)) {
+		pr_err("%s: Invalid input argument size\n", __func__);
+		ret = -EINVAL;
+		goto validate_exit;
+	}
+
+	switch (*cmd) {
+	case MSM_THERMAL_SET_CPU_MAX_FREQUENCY:
+	case MSM_THERMAL_SET_CPU_MIN_FREQUENCY:
+		if (query->cpu_freq.cpu_num >= num_possible_cpus()) {
+			pr_err("%s: Invalid CPU number: %u\n", __func__,
+				query->cpu_freq.cpu_num);
+			ret = -EINVAL;
+			goto validate_exit;
+		}
+		break;
+	default:
+		ret = -ENOTTY;
+		goto validate_exit;
+		break;
+	}
+
+validate_exit:
+	return ret;
+}
+
+static long msm_thermal_ioctl_process(struct file *filep, unsigned int cmd,
+	unsigned long arg)
+{
+	long ret = 0;
+	struct msm_thermal_ioctl query;
+
+	pr_debug("%s: IOCTL: processing cmd:%u\n", KBUILD_MODNAME, cmd);
+
+	ret = validate_and_copy(&cmd, &arg, &query);
+	if (ret)
+		goto process_exit;
+
+	switch (cmd) {
+	case MSM_THERMAL_SET_CPU_MAX_FREQUENCY:
+		ret = msm_thermal_set_frequency(query.cpu_freq.cpu_num,
+			query.cpu_freq.freq_req, true);
+		break;
+	case MSM_THERMAL_SET_CPU_MIN_FREQUENCY:
+		ret = msm_thermal_set_frequency(query.cpu_freq.cpu_num,
+			query.cpu_freq.freq_req, false);
+		break;
+	default:
+		ret = -ENOTTY;
+		goto process_exit;
+	}
+process_exit:
+	return ret;
+}
+
+static const struct file_operations msm_thermal_fops = {
+	.owner = THIS_MODULE,
+	.open = msm_thermal_ioctl_open,
+	.unlocked_ioctl = msm_thermal_ioctl_process,
+	.release = msm_thermal_ioctl_release,
+};
+
+int msm_thermal_ioctl_init()
+{
+	int ret = 0;
+	dev_t thermal_dev;
+	struct device *therm_device;
+
+	ret = alloc_chrdev_region(&thermal_dev, 0, 1,
+		MSM_THERMAL_IOCTL_NAME);
+	if (ret < 0) {
+		pr_err("%s: Error in allocating char device region. Err:%d\n",
+			KBUILD_MODNAME, ret);
+		goto ioctl_init_exit;
+	}
+
+	msm_thermal_major = MAJOR(thermal_dev);
+
+	thermal_class = class_create(THIS_MODULE, "msm_thermal");
+	if (IS_ERR(thermal_class)) {
+		pr_err("%s: Error in creating class\n",
+			KBUILD_MODNAME);
+		ret = PTR_ERR(thermal_class);
+		goto ioctl_class_fail;
+	}
+
+	therm_device = device_create(thermal_class, NULL, thermal_dev, NULL,
+				MSM_THERMAL_IOCTL_NAME);
+	if (IS_ERR(therm_device)) {
+		pr_err("%s: Error in creating character device\n",
+			KBUILD_MODNAME);
+		ret = PTR_ERR(therm_device);
+		goto ioctl_dev_fail;
+	}
+	msm_thermal_dev = kmalloc(sizeof(struct msm_thermal_ioctl_dev),
+				GFP_KERNEL);
+	if (!msm_thermal_dev) {
+		pr_err("%s: Error allocating memory\n",
+			KBUILD_MODNAME);
+		ret = -ENOMEM;
+		goto ioctl_clean_all;
+	}
+
+	memset(msm_thermal_dev, 0, sizeof(struct msm_thermal_ioctl_dev));
+	sema_init(&msm_thermal_dev->sem, 1);
+	cdev_init(&msm_thermal_dev->char_dev, &msm_thermal_fops);
+	ret = cdev_add(&msm_thermal_dev->char_dev, thermal_dev, 1);
+	if (ret < 0) {
+		pr_err("%s: Error in adding character device\n",
+			KBUILD_MODNAME);
+		goto ioctl_clean_all;
+	}
+
+	return ret;
+
+ioctl_clean_all:
+	device_destroy(thermal_class, thermal_dev);
+ioctl_dev_fail:
+	class_destroy(thermal_class);
+ioctl_class_fail:
+	unregister_chrdev_region(thermal_dev, 1);
+ioctl_init_exit:
+	return ret;
+}
+
+void msm_thermal_ioctl_cleanup()
+{
+	dev_t thermal_dev = MKDEV(msm_thermal_major, 0);
+
+	if (!msm_thermal_dev) {
+		pr_err("%s: Thermal IOCTL cleanup already done\n",
+			KBUILD_MODNAME);
+		return;
+	}
+
+	device_destroy(thermal_class, thermal_dev);
+	class_destroy(thermal_class);
+	cdev_del(&msm_thermal_dev->char_dev);
+	unregister_chrdev_region(thermal_dev, 1);
+	kfree(msm_thermal_dev);
+	msm_thermal_dev = NULL;
+	thermal_class = NULL;
+}
diff --git a/include/linux/Kbuild b/include/linux/Kbuild
index c052ebc..51a2dc7 100644
--- a/include/linux/Kbuild
+++ b/include/linux/Kbuild
@@ -420,6 +420,7 @@ header-y += wireless.h
 header-y += x25.h
 header-y += xattr.h
 header-y += xfrm.h
+header-y += msm_thermal_ioctl.h
 header-y += msm_adsp.h
 header-y += msm_mdp.h
 header-y += msm_kgsl.h
diff --git a/include/linux/msm_thermal.h b/include/linux/msm_thermal.h
index c98053a..c48941c 100755
--- a/include/linux/msm_thermal.h
+++ b/include/linux/msm_thermal.h
@@ -31,6 +31,8 @@ struct msm_thermal_data {
 #if defined (CONFIG_THERMAL_MONITOR) || defined (CONFIG_INTELLI_THERMAL)
 extern int msm_thermal_init(struct msm_thermal_data *pdata);
 extern int msm_thermal_device_init(void);
+extern int msm_thermal_set_frequency(uint32_t cpu, uint32_t freq,
+	bool is_max);
 #else
 static inline int msm_thermal_init(struct msm_thermal_data *pdata)
 {
@@ -40,6 +42,12 @@ static inline int msm_thermal_device_init(void)
 {
 	return -ENOSYS;
 }
+
+static inline int msm_thermal_set_frequency(uint32_t cpu, uint32_t freq,
+	bool is_max)
+{
+	return -ENOSYS;
+}
 #endif
 
 #endif /*__MSM_THERMAL_H*/
diff --git a/include/linux/msm_thermal_ioctl.h b/include/linux/msm_thermal_ioctl.h
new file mode 100755
index 0000000..7b36493
--- /dev/null
+++ b/include/linux/msm_thermal_ioctl.h
@@ -0,0 +1,41 @@
+#ifndef _MSM_THERMAL_IOCTL_H
+#define _MSM_THERMAL_IOCTL_H
+
+#include <linux/ioctl.h>
+
+#define MSM_THERMAL_IOCTL_NAME "msm_thermal_query"
+
+struct __attribute__((__packed__)) cpu_freq_arg {
+	uint32_t cpu_num;
+	uint32_t freq_req;
+};
+
+struct __attribute__((__packed__)) msm_thermal_ioctl {
+	uint32_t size;
+	union {
+		struct cpu_freq_arg cpu_freq;
+	};
+};
+
+enum {
+	/*Set CPU Frequency*/
+	MSM_SET_CPU_MAX_FREQ = 0x00,
+	MSM_SET_CPU_MIN_FREQ = 0x01,
+
+	MSM_CMD_MAX_NR,
+};
+
+#define MSM_THERMAL_MAGIC_NUM 0xCA /*Unique magic number*/
+
+#define MSM_THERMAL_SET_CPU_MAX_FREQUENCY _IOW(MSM_THERMAL_MAGIC_NUM,\
+		MSM_SET_CPU_MAX_FREQ, struct msm_thermal_ioctl)
+
+#define MSM_THERMAL_SET_CPU_MIN_FREQUENCY _IOW(MSM_THERMAL_MAGIC_NUM,\
+		MSM_SET_CPU_MIN_FREQ, struct msm_thermal_ioctl)
+
+#ifdef __KERNEL__
+extern int msm_thermal_ioctl_init(void);
+extern void msm_thermal_ioctl_cleanup(void);
+#endif
+
+#endif
