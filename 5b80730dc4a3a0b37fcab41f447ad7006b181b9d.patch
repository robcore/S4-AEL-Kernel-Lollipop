From 5b80730dc4a3a0b37fcab41f447ad7006b181b9d Mon Sep 17 00:00:00 2001
From: franciscofranco <franciscofranco.1990@gmail.com>
Date: Tue, 8 Jan 2013 23:09:43 -0800
Subject: [PATCH] drivers: msm_thermal: make thermal throttle temperature
 threshold user configurable.

Signed-off-by: franciscofranco <franciscofranco.1990@gmail.com>
---
 drivers/thermal/msm_thermal.c | 22 ++++++++--------------
 1 file changed, 8 insertions(+), 14 deletions(-)

diff --git a/drivers/thermal/msm_thermal.c b/drivers/thermal/msm_thermal.c
index 2dd2592..f518555 100644
--- a/drivers/thermal/msm_thermal.c
+++ b/drivers/thermal/msm_thermal.c
@@ -25,6 +25,11 @@
 #include <linux/of.h>
 #include <mach/cpufreq.h>
 
+#define POLLING_DELAY 100
+
+unsigned int temp_threshold = 60;
+module_param(temp_threshold, int, 0755);
+
 static int enabled;
 static struct msm_thermal_data msm_thermal_info;
 static uint32_t limited_max_freq = MSM_CPUFREQ_NO_LIMIT;
@@ -102,7 +107,7 @@ static void check_temp(struct work_struct *work)
 			limit_init = 1;
 	}
 
-	if (temp >= msm_thermal_info.limit_temp_degC) {
+	if (temp >= temp_threshold) {
 		if (limit_idx == limit_idx_low)
 			goto reschedule;
 
@@ -110,7 +115,7 @@ static void check_temp(struct work_struct *work)
 		if (limit_idx < limit_idx_low)
 			limit_idx = limit_idx_low;
 		max_freq = table[limit_idx].frequency;
-	} else if (temp < msm_thermal_info.limit_temp_degC -
+	} else if (temp < temp_threshold -
 		 msm_thermal_info.temp_hysteresis_degC) {
 		if (limit_idx == limit_idx_high)
 			goto reschedule;
@@ -135,8 +140,7 @@ static void check_temp(struct work_struct *work)
 
 reschedule:
 	if (enabled)
-		schedule_delayed_work(&check_temp_work,
-				msecs_to_jiffies(msm_thermal_info.poll_ms));
+		schedule_delayed_work(&check_temp_work, msecs_to_jiffies(POLLING_DELAY));
 }
 
 static void disable_msm_thermal(void)
@@ -207,16 +211,6 @@ static int __devinit msm_thermal_dev_probe(struct platform_device *pdev)
 		goto fail;
 	WARN_ON(data.sensor_id >= TSENS_MAX_SENSORS);
 
-	key = "qcom,poll-ms";
-	ret = of_property_read_u32(node, key, &data.poll_ms);
-	if (ret)
-		goto fail;
-
-	key = "qcom,limit-temp";
-	ret = of_property_read_u32(node, key, &data.limit_temp_degC);
-	if (ret)
-		goto fail;
-
 	key = "qcom,temp-hysteresis";
 	ret = of_property_read_u32(node, key, &data.temp_hysteresis_degC);
 	if (ret)
