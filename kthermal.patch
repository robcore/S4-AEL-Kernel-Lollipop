From a9a8daaae1a22ef86ddc70f2303ae5919ad3ecf6 Mon Sep 17 00:00:00 2001
From: ktoonsez <ktoonsez@gmail.com>
Date: Thu, 13 Nov 2014 17:42:30 -0700
Subject: [PATCH] Add KThermal

---
 arch/arm/configs/apq8084_sec_defconfig |   2 +-
 arch/arm/mach-msm/Makefile             |   1 +
 arch/arm/mach-msm/board-8084.c         |   2 +-
 arch/arm/mach-msm/board-8974.c         |   2 +-
 arch/arm/mach-msm/kthermal.c           | 329 +++++++++++++++++++++++++++++++++
 arch/arm/mach-msm/kthermal.h           |  38 ++++
 6 files changed, 371 insertions(+), 3 deletions(-)
 create mode 100644 arch/arm/mach-msm/kthermal.c
 create mode 100644 arch/arm/mach-msm/kthermal.h

diff --git a/arch/arm/configs/apq8084_sec_defconfig b/arch/arm/configs/apq8084_sec_defconfig
index 45245e7..0319d44 100755
--- a/arch/arm/configs/apq8084_sec_defconfig
+++ b/arch/arm/configs/apq8084_sec_defconfig
@@ -388,7 +388,7 @@ CONFIG_SENSORS_QPNP_ADC_VOLTAGE=y
 CONFIG_SENSORS_QPNP_ADC_CURRENT=y
 CONFIG_THERMAL=y
 CONFIG_THERMAL_TSENS8974=y
-CONFIG_THERMAL_MONITOR=y
+# CONFIG_THERMAL_MONITOR is not set
 CONFIG_THERMAL_QPNP=y
 CONFIG_THERMAL_QPNP_ADC_TM=y
 CONFIG_WCD9320_CODEC=y
diff --git a/arch/arm/mach-msm/Makefile b/arch/arm/mach-msm/Makefile
index d5a8f0a..a52a616 100755
--- a/arch/arm/mach-msm/Makefile
+++ b/arch/arm/mach-msm/Makefile
@@ -150,3 +150,4 @@ obj-$(CONFIG_SEC_BSP) += sec_bsp.o
 obj-$(CONFIG_SEC_THERMISTOR) += sec_thermistor.o apq8084-thermistor.o
 obj-$(CONFIG_BT_BCM4358) += board-bluetooth-bcm4358.o
 obj-$(CONFIG_GSM_MODEM_SPRD6500) += board-sprd6500-spi.o board-sprd6500-modems.o
+obj-y += kthermal.o
diff --git a/arch/arm/mach-msm/board-8084.c b/arch/arm/mach-msm/board-8084.c
index 638e008..ea9007a 100755
--- a/arch/arm/mach-msm/board-8084.c
+++ b/arch/arm/mach-msm/board-8084.c
@@ -473,7 +473,7 @@ void __init apq8084_add_drivers(void)
 	else
 		msm_clock_init(&apq8084_clock_init_data);
 	tsens_tm_init_driver();
-	msm_thermal_device_init();
+	//msm_thermal_device_init();
 }
 
 static void __init apq8084_map_io(void)
diff --git a/arch/arm/mach-msm/board-8974.c b/arch/arm/mach-msm/board-8974.c
index 3b142d3..ff82344 100755
--- a/arch/arm/mach-msm/board-8974.c
+++ b/arch/arm/mach-msm/board-8974.c
@@ -68,7 +68,7 @@ void __init msm8974_add_drivers(void)
 	msm_spm_device_init();
 	krait_power_init();
 	tsens_tm_init_driver();
-	msm_thermal_device_init();
+	//msm_thermal_device_init();
 }
 
 static struct of_dev_auxdata msm_hsic_host_adata[] = {
diff --git a/arch/arm/mach-msm/kthermal.c b/arch/arm/mach-msm/kthermal.c
new file mode 100644
index 0000000..2ba0d8b
--- /dev/null
+++ b/arch/arm/mach-msm/kthermal.c
@@ -0,0 +1,329 @@
+#include "kthermal.h"
+
+static struct delayed_work check_temp_workk;
+static struct cpufreq_frequency_table *table;
+
+static int limit_idx = 18;
+static int limit_idx_low = 3;
+static int limit_idx_high = 18;
+
+extern void do_kthermal(unsigned int cpu, unsigned int freq);
+
+static int thermal_get_freq_table(void)
+{
+	int ret = 0;
+	int i = 0;
+	struct cpufreq_policy *policy = cpufreq_cpu_get(0);
+	
+	table = cpufreq_frequency_get_table(0);
+	if (table == NULL) {
+		pr_debug("%s: error reading cpufreq table\n", KBUILD_MODNAME);
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	while (table[i].frequency != CPUFREQ_TABLE_END)
+	{
+		//pr_alert("LOAD TABLE %d-%d-%d-%d\n", table[i].frequency, kmsm_thermal_info.minimum_throttle_mhz, limit_idx_low, limit_idx_high);
+		if (kmsm_thermal_info.minimum_throttle_mhz == table[i].frequency)
+			limit_idx_low = i;
+		if (policy->user_policy.max == table[i].frequency)
+			limit_idx_high = i;
+		i++;
+	}
+	limit_idx = limit_idx_high;
+	pr_alert("LOADED THERMAL TABLE: low=%d high=%d current limit = %d\n", limit_idx_low, limit_idx_high, limit_idx);
+fail:
+	return ret;
+}
+
+static void __cpuinit check_tempk(struct work_struct *work)
+{
+	unsigned int new_freq;
+	struct tsens_device tsens_dev;
+	long temp = 0;
+	int ret = 0;
+	
+	tsens_dev.sensor_num = kmsm_thermal_info.sensor_id;
+	ret = tsens_get_temp(&tsens_dev, &temp);
+	kmsm_thermal_info.current_temp = temp;
+	if (ret) {
+		pr_alert("%s: Unable to read TSENS sensor %d, ERROR: %d\n",
+				KBUILD_MODNAME, tsens_dev.sensor_num, ret);
+		goto reschedule;
+	}
+	//pr_alert("CHECK TEMP %lu-%d-%d\n", temp, kmsm_thermal_info.temp_limit_degC_start, kmsm_thermal_info.temp_limit_degC_stop);
+	
+	if (!kmsm_thermal_info.use_kthermal)
+		goto reschedule;
+		
+	if (temp >= kmsm_thermal_info.temp_limit_degC_start)
+	{
+		unsigned int i;
+		if (!kmsm_thermal_info.isthrottling)
+		{
+			//prev_freq = cpufreq_get(0);
+			thermal_get_freq_table();
+			pr_alert("START KTHROTTLING - current temp = %lu - set point = %d\n", temp, kmsm_thermal_info.temp_limit_degC_start);
+		}
+		kmsm_thermal_info.isthrottling = 1;
+		//policy = cpufreq_cpu_get(0);
+		//__cpufreq_driver_target(policy, 1296000, CPUFREQ_RELATION_H);
+		limit_idx -= kmsm_thermal_info.freq_steps_while_throttling;
+		if (limit_idx < limit_idx_low)
+			limit_idx = limit_idx_low;
+		for (i = 0; i < num_online_cpus(); i++)
+		{
+			//pr_alert("KTHROTTLING LOOP - current temp = %lu - set point = %d\n", temp, kmsm_thermal_info.temp_limit_degC_start);
+			if (cpu_online(i) && cpufreq_get(i) != table[limit_idx].frequency)
+			{
+				//pr_alert("KTHROTTLING LOOP IN IF - current temp = %lu - set point = %d\n", temp, kmsm_thermal_info.temp_limit_degC_start);
+				//policy = NULL;
+				//policy = cpufreq_cpu_get(i);
+				//if (policy != NULL)
+				//	__cpufreq_driver_target(policy, 1296000, CPUFREQ_RELATION_H);
+				new_freq = table[limit_idx].frequency;
+				do_kthermal(i, new_freq);
+			}
+		}
+	}
+	else if (kmsm_thermal_info.isthrottling && temp > kmsm_thermal_info.temp_limit_degC_stop && temp < kmsm_thermal_info.temp_limit_degC_start)
+	{
+		unsigned int i;
+		for (i = 0; i < num_online_cpus(); i++)
+		{
+			if (cpu_online(i) && cpufreq_get(i) != table[limit_idx].frequency)
+			{
+				new_freq = table[limit_idx].frequency;
+				do_kthermal(i, new_freq);
+			}
+		}
+	}
+	else if (kmsm_thermal_info.isthrottling && temp <= kmsm_thermal_info.temp_limit_degC_stop)
+	{
+		unsigned int i;
+		bool stopThrottle = false;
+		//policy = cpufreq_cpu_get(0);
+		//if (prev_freq > 0)
+		//	__cpufreq_driver_target(policy, prev_freq, CPUFREQ_RELATION_H);
+		limit_idx += kmsm_thermal_info.freq_steps_while_throttling;
+		if (limit_idx >= limit_idx_high)
+		{
+			limit_idx = limit_idx_high;
+			kmsm_thermal_info.isthrottling = 0;
+			stopThrottle = true;
+			pr_alert("STOP KTHROTTLING - current temp = %lu\n", temp);
+		}
+		for (i = 0; i < num_online_cpus(); i++)
+		{
+			if (cpu_online(i))
+			{
+				//policy = NULL;
+				//policy = cpufreq_cpu_get(i);
+				//if (prev_freq > 0 && policy != NULL)
+				//	__cpufreq_driver_target(policy, prev_freq, CPUFREQ_RELATION_H);
+				//do_thermal(i, prev_freq);
+				new_freq = table[limit_idx].frequency;
+				do_kthermal(i, new_freq);
+			}
+		}
+		if (stopThrottle)
+			do_kthermal(0, 0);
+	}
+
+reschedule:
+	schedule_delayed_work_on(0, &check_temp_workk,
+			msecs_to_jiffies(kmsm_thermal_info.poll_speed));
+}
+
+bool are_we_tthrottling(void)
+{
+	return kmsm_thermal_info.isthrottling;
+}
+
+static ssize_t show_isthrottling(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", kmsm_thermal_info.isthrottling);
+}
+
+static ssize_t show_poll_speed(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", kmsm_thermal_info.poll_speed);
+}
+
+static ssize_t store_poll_speed(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	unsigned int value = 0;
+
+	ret = sscanf(buf, "%u", &value);
+	if (ret != 1)
+		return -EINVAL;
+	
+	if (value < 100)
+		value = 100;
+	kmsm_thermal_info.poll_speed = value;
+	return count;
+}
+
+static ssize_t show_use_kthermal(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", kmsm_thermal_info.use_kthermal);
+}
+
+static ssize_t store_use_kthermal(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	unsigned int value = 0;
+
+	ret = sscanf(buf, "%u", &value);
+	if (ret != 1)
+		return -EINVAL;
+	
+	if (value != 0 && value != 1)
+		value = 0;
+	kmsm_thermal_info.use_kthermal = value;
+	return count;
+}
+
+static ssize_t show_current_temp(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", kmsm_thermal_info.current_temp);
+}
+
+static ssize_t show_temp_limit_degC_start(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", kmsm_thermal_info.temp_limit_degC_start);
+}
+
+static ssize_t store_temp_limit_degC_start(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	unsigned int value = 0;
+
+	ret = sscanf(buf, "%u", &value);
+	if (ret != 1)
+		return -EINVAL;
+	
+	if (value < kmsm_thermal_info.temp_limit_degC_stop)
+		value = kmsm_thermal_info.temp_limit_degC_stop + 1;
+		
+	kmsm_thermal_info.temp_limit_degC_start = value;
+	return count;
+}
+
+static ssize_t show_temp_limit_degC_stop(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", kmsm_thermal_info.temp_limit_degC_stop);
+}
+
+static ssize_t store_temp_limit_degC_stop(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	unsigned int value = 0;
+
+	ret = sscanf(buf, "%u", &value);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (value > kmsm_thermal_info.temp_limit_degC_start)
+		value = kmsm_thermal_info.temp_limit_degC_start - 1;
+
+	kmsm_thermal_info.temp_limit_degC_stop = value;
+	return count;
+}
+
+static ssize_t show_freq_steps_while_throttling(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", kmsm_thermal_info.freq_steps_while_throttling);
+}
+
+static ssize_t store_freq_steps_while_throttling(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	unsigned int value = 0;
+
+	ret = sscanf(buf, "%u", &value);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (value < 0 || value > 5)
+		value = 1;
+	kmsm_thermal_info.freq_steps_while_throttling = value;
+	return count;
+}
+
+static ssize_t show_minimum_throttle_mhz(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", kmsm_thermal_info.minimum_throttle_mhz);
+}
+
+static ssize_t store_minimum_throttle_mhz(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	unsigned int value = 0;
+
+	ret = sscanf(buf, "%u", &value);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (value <= 0)
+		value = 378000;
+		
+	kmsm_thermal_info.minimum_throttle_mhz = value;
+	return count;
+}
+
+static struct global_attr isthrottling_attr = __ATTR(isthrottling, 0444, show_isthrottling, NULL);
+static struct global_attr poll_speed_attr = __ATTR(poll_speed, 0666, show_poll_speed, store_poll_speed);
+static struct global_attr current_temp_attr = __ATTR(current_temp, 0444, show_current_temp, NULL);
+static struct global_attr temp_limit_degC_start_attr = __ATTR(temp_limit_degC_start, 0666, show_temp_limit_degC_start, store_temp_limit_degC_start);
+static struct global_attr temp_limit_degC_stop_attr = __ATTR(temp_limit_degC_stop, 0666, show_temp_limit_degC_stop, store_temp_limit_degC_stop);
+static struct global_attr freq_steps_while_throttling_attr = __ATTR(freq_steps_while_throttling, 0666, show_freq_steps_while_throttling, store_freq_steps_while_throttling);
+static struct global_attr minimum_throttle_mhz_attr = __ATTR(minimum_throttle_mhz, 0666, show_minimum_throttle_mhz, store_minimum_throttle_mhz);
+static struct global_attr use_kthermal_attr = __ATTR(use_kthermal, 0666, show_use_kthermal, store_use_kthermal);
+
+static struct attribute *kthermal_attributes[] = {
+	&isthrottling_attr.attr,
+	&poll_speed_attr.attr,
+	&current_temp_attr.attr,
+	&temp_limit_degC_start_attr.attr,
+	&temp_limit_degC_stop_attr.attr,
+	&freq_steps_while_throttling_attr.attr,
+	&minimum_throttle_mhz_attr.attr,
+	&use_kthermal_attr.attr,
+	NULL,
+};
+
+static struct attribute_group kthermal_attr_group = {
+	.attrs = kthermal_attributes,
+	.name = "kthermal",
+};
+
+static int __init start_kthermal(void)
+{
+	int rc;
+	rc = sysfs_create_group(cpufreq_global_kobject,
+				&kthermal_attr_group);
+
+	pr_alert("START KTHERMAL\n");
+	INIT_DELAYED_WORK(&check_temp_workk, check_tempk);
+	schedule_delayed_work_on(0, &check_temp_workk, msecs_to_jiffies(60000));
+	
+	return 0;
+}
+late_initcall(start_kthermal);
diff --git a/arch/arm/mach-msm/kthermal.h b/arch/arm/mach-msm/kthermal.h
new file mode 100644
index 0000000..e4cbdc3
--- /dev/null
+++ b/arch/arm/mach-msm/kthermal.h
@@ -0,0 +1,38 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/msm_tsens.h>
+#include <linux/workqueue.h>
+#include <linux/cpu.h>
+#include <linux/cpufreq.h>
+#include <linux/msm_tsens.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+
+struct kmsm_thermal_data {
+	uint32_t sensor_id;
+	int isthrottling;
+	uint32_t poll_speed;
+	uint32_t temp_limit_degC_start;
+	uint32_t temp_limit_degC_stop;
+	uint32_t freq_steps_while_throttling;
+	uint32_t minimum_throttle_mhz;
+	uint32_t core_limit_temp_degC;
+	uint32_t core_temp_hysteresis_degC;
+	uint32_t core_control_mask;
+	long current_temp;
+	int use_kthermal;
+};
+
+static struct kmsm_thermal_data kmsm_thermal_info = {
+	.sensor_id = 0,
+	.isthrottling = false,
+	.poll_speed = 1000,
+	.temp_limit_degC_start = 77,
+	.temp_limit_degC_stop = 75,
+	.freq_steps_while_throttling = 1,
+	.minimum_throttle_mhz = 960000,
+	.current_temp = 0,
+	.use_kthermal = 0,
+};
