From f25c7f6897ddd13fcfb7efc454d2cf913244d635 Mon Sep 17 00:00:00 2001
From: ausdim <koronaios@gmail.com>
Date: Thu, 22 Aug 2013 21:16:11 +0300
Subject: [PATCH] Fs changes to fix random restarts (Thanks to ktoonsez)

---
 fs/aio.c                      |  4 ----
 fs/btrfs/disk-io.c            |  8 ++++----
 fs/btrfs/file.c               |  3 +--
 fs/btrfs/ioctl.c              |  2 +-
 fs/cifs/transport.c           |  3 ++-
 fs/file.c                     | 15 ---------------
 fs/jbd2/journal.c             |  8 --------
 fs/ocfs2/file.c               |  5 +----
 fs/splice.c                   |  5 +----
 9 files changed, 7 insertions(+), 40 deletions(-)

diff --git a/fs/aio.c b/fs/aio.c
index cdc8dc4..01be7f6 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -1680,7 +1680,6 @@ long do_io_submit(aio_context_t ctx_id, long nr,
 	struct kioctx *ctx;
 	long ret = 0;
 	int i = 0;
-	struct blk_plug plug;
 	struct kiocb_batch batch;
 
 	if (unlikely(nr < 0))
@@ -1700,8 +1699,6 @@ long do_io_submit(aio_context_t ctx_id, long nr,
 
 	kiocb_batch_init(&batch, nr);
 
-	blk_start_plug(&plug);
-
 	/*
 	 * AKPM: should this return a partial result if some of the IOs were
 	 * successfully submitted?
@@ -1724,7 +1721,6 @@ long do_io_submit(aio_context_t ctx_id, long nr,
 		if (ret)
 			break;
 	}
-	blk_finish_plug(&plug);
 
 	kiocb_batch_free(ctx, &batch);
 	put_ioctx(ctx);
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index a7ffc88..94705d5 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -3210,8 +3210,8 @@ void btrfs_btree_balance_dirty(struct btrfs_root *root, unsigned long nr)
 	num_dirty = root->fs_info->dirty_metadata_bytes;
 
 	if (num_dirty > thresh) {
-		balance_dirty_pages_ratelimited_nr(
-				   root->fs_info->btree_inode->i_mapping, 1);
+		balance_dirty_pages_ratelimited(
+				   root->fs_info->btree_inode->i_mapping);
 	}
 	return;
 }
@@ -3231,8 +3231,8 @@ void __btrfs_btree_balance_dirty(struct btrfs_root *root, unsigned long nr)
 	num_dirty = root->fs_info->dirty_metadata_bytes;
 
 	if (num_dirty > thresh) {
-		balance_dirty_pages_ratelimited_nr(
-				   root->fs_info->btree_inode->i_mapping, 1);
+		balance_dirty_pages_ratelimited(
+				   root->fs_info->btree_inode->i_mapping);
 	}
 	return;
 }
diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c
index 53bf2d7..721f4f3 100644
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -1285,8 +1285,7 @@ static noinline ssize_t __btrfs_buffered_write(struct file *file,
 
 		cond_resched();
 
-		balance_dirty_pages_ratelimited_nr(inode->i_mapping,
-						   dirty_pages);
+		balance_dirty_pages_ratelimited(inode->i_mapping);
 		if (dirty_pages < (root->leafsize >> PAGE_CACHE_SHIFT) + 1)
 			btrfs_btree_balance_dirty(root, 1);
 
diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index 3a65f43..0b2d993 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -1179,7 +1179,7 @@ int btrfs_defrag_file(struct inode *inode, struct file *file,
 		}
 
 		defrag_count += ret;
-		balance_dirty_pages_ratelimited_nr(inode->i_mapping, ret);
+		balance_dirty_pages_ratelimited(inode->i_mapping);
 		mutex_unlock(&inode->i_mutex);
 
 		if (newer_than) {
diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c
index f227399..b48743c 100644
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -650,7 +650,8 @@ SendReceive2(const unsigned int xid, struct cifs_ses *ses,
 
 	cifs_small_buf_release(buf);
 
-	rc = cifs_sync_mid_result(midQ, ses->server);
+	if (midQ != NULL)
+		rc = cifs_sync_mid_result(midQ, ses->server);
 	if (rc != 0) {
 		cifs_add_credits(ses->server, 1);
 		return rc;
diff --git a/fs/file.c b/fs/file.c
index 0bb0453..ba3f605 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -210,17 +210,13 @@ static int expand_fdtable(struct files_struct *files, int nr)
 	new_fdt = alloc_fdtable(nr);
 	spin_lock(&files->file_lock);
 	if (!new_fdt)
-	{
-		printk("[expand_fdtable] ENOMEM: !new_fdt\n");
 		return -ENOMEM;
-	}
 	/*
 	 * extremely unlikely race - sysctl_nr_open decreased between the check in
 	 * caller and alloc_fdtable().  Cheaper to catch it here...
 	 */
 	if (unlikely(new_fdt->max_fds <= nr)) {
 		__free_fdtable(new_fdt);
-		printk("[expand_fdtable] EMFILE : unlikely(new_fdt->max_fds <= nr\n)"); 
 		return -EMFILE;
 	}
 	/*
@@ -259,14 +255,8 @@ int expand_files(struct files_struct *files, int nr)
 	 * N.B. For clone tasks sharing a files structure, this test
 	 * will limit the total number of files that can be opened.
 	 */
-
 	if (nr >= rlimit(RLIMIT_NOFILE))
-	{
-		pr_err("[expand_files] NR : %d, RLIMIT : %lu, PID : %d, Process Name : %s\n",
-				nr, rlimit(RLIMIT_NOFILE), current->pid, current->comm);
-
 		return -EMFILE;
-	}
 
 	/* Do we need to expand? */
 	if (nr < fdt->max_fds)
@@ -274,10 +264,7 @@ int expand_files(struct files_struct *files, int nr)
 
 	/* Can we expand? */
 	if (nr >= sysctl_nr_open)
-	{
-		printk("[expand_files] EMFILE : nr >= sysctl_nr_open\n");
 		return -EMFILE;
-	}
 
 	/* All good, so we try */
 	return expand_fdtable(files, nr);
@@ -477,8 +464,6 @@ int alloc_fd(unsigned start, unsigned flags)
 	else
 		__clear_close_on_exec(fd, fdt);
 	error = fd;
-	if (error < 0)
-		printk("[alloc_fd] fd < 0\n");
 #if 1
 	/* Sanity check */
 	if (rcu_dereference_raw(fdt->fd[fd]) != NULL) {
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index d32ddb3..e5bfb11 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -1419,14 +1419,6 @@ static int journal_get_superblock(journal_t *journal)
 		goto out;
 	}
 
-	if (be32_to_cpu(sb->s_first) == 0 ||
-	    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {
-		printk(KERN_WARNING
-			"JBD2: Invalid start block of journal: %u\n",
-			be32_to_cpu(sb->s_first));
-		goto out;
-	}
-
 	return 0;
 
 out:
diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c
index 7602783..d5facce 100644
--- a/fs/ocfs2/file.c
+++ b/fs/ocfs2/file.c
@@ -2508,18 +2508,15 @@ static ssize_t ocfs2_file_splice_write(struct pipe_inode_info *pipe,
 		ret = sd.num_spliced;
 
 	if (ret > 0) {
-		unsigned long nr_pages;
 		int err;
 
-		nr_pages = (ret + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
-
 		err = generic_write_sync(out, *ppos, ret);
 		if (err)
 			ret = err;
 		else
 			*ppos += ret;
 
-		balance_dirty_pages_ratelimited_nr(mapping, nr_pages);
+		balance_dirty_pages_ratelimited(mapping);
 	}
 
 	return ret;
diff --git a/fs/splice.c b/fs/splice.c
index bed6a3c..8f89ac5 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -1022,17 +1022,14 @@ generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,
 		ret = sd.num_spliced;
 
 	if (ret > 0) {
-		unsigned long nr_pages;
 		int err;
 
-		nr_pages = (ret + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
-
 		err = generic_write_sync(out, *ppos, ret);
 		if (err)
 			ret = err;
 		else
 			*ppos += ret;
-		balance_dirty_pages_ratelimited_nr(mapping, nr_pages);
+		balance_dirty_pages_ratelimited(mapping);
 	}
 
 	return ret;
