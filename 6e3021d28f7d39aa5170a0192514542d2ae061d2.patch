From 6e3021d28f7d39aa5170a0192514542d2ae061d2 Mon Sep 17 00:00:00 2001
From: Dipen Parmar <dipenp@codeaurora.org>
Date: Mon, 13 Jan 2014 15:22:52 +0530
Subject: [PATCH] thermal: msm: Remove early init from board file

Remove early initialization of TSENS
(temperature sensors driver) and Thermal drivers
from the existing board file. These can instead have
early driver initialization by changing the init calls
to use arch_init_call(). This allows having to support
boards that may not have a board file support.

Adding the initcall change within TSENS driver also
requires changing the client Thermal driver within
the same patch to avoid a crash due to dependencies
of early initialiation between these two drivers.
To avoid this also add support within the TSENS
driver to check for probe deferral and corresponding
changes to the Thermal driver to call this API.
Also include the data type check to avoid compilation
within the TSENS driver.

Signed-off-by: Dipen Parmar <dipenp@codeaurora.org>
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>

Conflicts:
	drivers/thermal/Makefile
	drivers/thermal/msm8974-tsens.c
---
 arch/arm/mach-msm/board-8084.c     |  4 --
 arch/arm/mach-msm/board-8092.c     |  5 ---
 arch/arm/mach-msm/board-8916.c     |  4 --
 arch/arm/mach-msm/board-8974.c     |  4 --
 arch/arm/mach-msm/board-fsm9900.c  |  4 --
 arch/arm/mach-msm/board-samarium.c |  4 --
 drivers/thermal/Makefile           |  2 +-
 drivers/thermal/msm8974-tsens.c    | 86 +++++++++++++++++++++++++-------------
 drivers/thermal/msm_thermal.c      | 13 +++++-
 include/linux/msm_tsens.h          |  5 ++-
 10 files changed, 73 insertions(+), 58 deletions(-)

diff --git a/arch/arm/mach-msm/board-8084.c b/arch/arm/mach-msm/board-8084.c
index 09d2c88..53751c2 100644
--- a/arch/arm/mach-msm/board-8084.c
+++ b/arch/arm/mach-msm/board-8084.c
@@ -18,8 +18,6 @@
 #include <linux/memory.h>
 #include <linux/regulator/krait-regulator.h>
 #include <linux/regulator/rpm-smd-regulator.h>
-#include <linux/msm_tsens.h>
-#include <linux/msm_thermal.h>
 #include <linux/clk/msm-clk-provider.h>
 #include <asm/mach/map.h>
 #include <asm/mach/arch.h>
@@ -79,8 +77,6 @@ void __init apq8084_add_drivers(void)
 		msm_clock_init(&apq8084_rumi_clock_init_data);
 	else
 		msm_clock_init(&apq8084_clock_init_data);
-	tsens_tm_init_driver();
-	msm_thermal_device_init();
 }
 
 static void __init apq8084_map_io(void)
diff --git a/arch/arm/mach-msm/board-8092.c b/arch/arm/mach-msm/board-8092.c
index 1905df9..5b001f7 100644
--- a/arch/arm/mach-msm/board-8092.c
+++ b/arch/arm/mach-msm/board-8092.c
@@ -19,8 +19,6 @@
 #include <linux/of_platform.h>
 #include <linux/of_fdt.h>
 #include <linux/of_irq.h>
-#include <linux/msm_tsens.h>
-#include <linux/msm_thermal.h>
 #include <linux/clk/msm-clk-provider.h>
 #include <linux/regulator/rpm-smd-regulator.h>
 #include <asm/mach/arch.h>
@@ -157,9 +155,6 @@ void __init mpq8092_add_drivers(void)
 		msm_clock_init(&mpq8092_rumi_clock_init_data);
 	else
 		msm_clock_init(&mpq8092_clock_init_data);
-	tsens_tm_init_driver();
-	msm_thermal_device_init();
-
 	emac_dt_update(0, MPQ8092_MAC_FUSE_PHYS, MPQ8092_MAC_FUSE_SIZE);
 }
 
diff --git a/arch/arm/mach-msm/board-8916.c b/arch/arm/mach-msm/board-8916.c
index 632226c..3296186 100644
--- a/arch/arm/mach-msm/board-8916.c
+++ b/arch/arm/mach-msm/board-8916.c
@@ -16,8 +16,6 @@
 #include <linux/of_platform.h>
 #include <linux/of_fdt.h>
 #include <linux/of_irq.h>
-#include <linux/msm_tsens.h>
-#include <linux/msm_thermal.h>
 #include <asm/mach/arch.h>
 #include <soc/qcom/socinfo.h>
 #include <mach/board.h>
@@ -63,8 +61,6 @@ void __init msm8916_add_drivers(void)
 	msm_rpm_driver_init();
 	msm_spm_device_init();
 	msm_pm_sleep_status_init();
-	tsens_tm_init_driver();
-	msm_thermal_device_init();
 }
 
 static void __init msm8916_init(void)
diff --git a/arch/arm/mach-msm/board-8974.c b/arch/arm/mach-msm/board-8974.c
index 8c6aa46..2c96d7d 100644
--- a/arch/arm/mach-msm/board-8974.c
+++ b/arch/arm/mach-msm/board-8974.c
@@ -23,8 +23,6 @@
 #include <linux/regulator/machine.h>
 #include <linux/regulator/krait-regulator.h>
 #include <linux/regulator/rpm-smd-regulator.h>
-#include <linux/msm_tsens.h>
-#include <linux/msm_thermal.h>
 #include <asm/mach/map.h>
 #include <asm/mach/map.h>
 #include <asm/mach/arch.h>
@@ -67,8 +65,6 @@ void __init msm8974_add_drivers(void)
 	rpm_smd_regulator_driver_init();
 	msm_spm_device_init();
 	krait_power_init();
-	tsens_tm_init_driver();
-	msm_thermal_device_init();
 }
 
 static struct of_dev_auxdata msm_hsic_host_adata[] = {
diff --git a/arch/arm/mach-msm/board-fsm9900.c b/arch/arm/mach-msm/board-fsm9900.c
index ab524f5..9158584 100644
--- a/arch/arm/mach-msm/board-fsm9900.c
+++ b/arch/arm/mach-msm/board-fsm9900.c
@@ -17,8 +17,6 @@
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/memory.h>
-#include <linux/msm_tsens.h>
-#include <linux/msm_thermal.h>
 #include <linux/clk/msm-clk-provider.h>
 #include <asm/mach/map.h>
 #include <asm/mach/arch.h>
@@ -67,8 +65,6 @@ void __init fsm9900_add_drivers(void)
 		msm_clock_init(&fsm9900_dummy_clock_init_data);
 	else
 		msm_clock_init(&fsm9900_clock_init_data);
-	tsens_tm_init_driver();
-	msm_thermal_device_init();
 }
 
 static void __init fsm9900_map_io(void)
diff --git a/arch/arm/mach-msm/board-samarium.c b/arch/arm/mach-msm/board-samarium.c
index 77e938f..03dcd74 100644
--- a/arch/arm/mach-msm/board-samarium.c
+++ b/arch/arm/mach-msm/board-samarium.c
@@ -16,8 +16,6 @@
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/memory.h>
-#include <linux/msm_tsens.h>
-#include <linux/msm_thermal.h>
 #include <linux/clk/msm-clk-provider.h>
 #include <linux/regulator/rpm-smd-regulator.h>
 #include <asm/mach/map.h>
@@ -79,8 +77,6 @@ void __init msmsamarium_add_drivers(void)
 		msm_clock_init(&msmsamarium_rumi_clock_init_data);
 	else
 		msm_clock_init(&msmsamarium_clock_init_data);
-	tsens_tm_init_driver();
-	msm_thermal_device_init();
 }
 
 static void __init msmsamarium_map_io(void)
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index 9249273..498b47e 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -23,8 +23,8 @@ obj-$(CONFIG_DB8500_THERMAL)	+= db8500_thermal.o
 obj-$(CONFIG_ARMADA_THERMAL)	+= armada_thermal.o
 obj-$(CONFIG_DB8500_CPUFREQ_COOLING)	+= db8500_cpufreq_cooling.o
 obj-$(CONFIG_INTEL_POWERCLAMP)	+= intel_powerclamp.o
-obj-$(CONFIG_THERMAL_MONITOR)	+= msm_thermal.o msm_thermal-dev.o
 obj-$(CONFIG_INTELLI_THERMAL)	+= intelli/msm_thermal.o
 obj-$(CONFIG_THERMAL_TSENS8974)	+= msm8974-tsens.o
 obj-$(CONFIG_THERMAL_QPNP)	+= qpnp-temp-alarm.o
 obj-$(CONFIG_THERMAL_QPNP_ADC_TM)	+= qpnp-adc-tm.o
+obj-$(CONFIG_THERMAL_MONITOR)	+= msm_thermal.o msm_thermal-dev.o
diff --git a/drivers/thermal/msm8974-tsens.c b/drivers/thermal/msm8974-tsens.c
index 9697255..d74778f 100644
--- a/drivers/thermal/msm8974-tsens.c
+++ b/drivers/thermal/msm8974-tsens.c
@@ -27,8 +27,6 @@
 #include <linux/of.h>
 #include <linux/wakelock.h>
 
-#include <mach/msm_iomap.h>
-
 #define CREATE_TRACE_POINTS
 #include <trace/trace_thermal.h>
 
@@ -374,6 +372,7 @@ struct tsens_tm_device {
 	struct platform_device		*pdev;
 	struct workqueue_struct		*tsens_wq;
 	struct wake_lock		wakelock;
+	bool				is_ready;
 	bool				prev_reading_avail;
 	bool				calibration_less_mode;
 	bool				tsens_local_init;
@@ -394,11 +393,26 @@ struct tsens_tm_device {
 
 struct tsens_tm_device *tmdev;
 
+
+int tsens_is_ready()
+{
+	if (!tmdev)
+		return -EPROBE_DEFER;
+	else
+		return tmdev->is_ready;
+}
+EXPORT_SYMBOL(tsens_is_ready);
+
 int tsens_get_sw_id_mapping(int sensor_hw_num, int *sensor_sw_idx)
 {
 	int i = 0;
 	bool id_found = false;
 
+	if (tsens_is_ready() <= 0) {
+		pr_debug("TSENS early init not done\n");
+		return -EPROBE_DEFER;
+	}
+
 	while (i < tmdev->tsens_num_sensor && !id_found) {
 		if (sensor_hw_num == tmdev->sensor[i].sensor_hw_num) {
 			*sensor_sw_idx = tmdev->sensor[i].sensor_sw_id;
@@ -419,6 +433,11 @@ int tsens_get_hw_id_mapping(int sensor_sw_id, int *sensor_hw_num)
 	int i = 0;
 	bool id_found = false;
 
+	if (tsens_is_ready() <= 0) {
+		pr_debug("TSENS early init not done\n");
+		return -EPROBE_DEFER;
+	}
+
 	while (i < tmdev->tsens_num_sensor && !id_found) {
 		if (sensor_sw_id == tmdev->sensor[i].sensor_sw_id) {
 			*sensor_hw_num = tmdev->sensor[i].sensor_hw_num;
@@ -472,33 +491,32 @@ static int tsens_tz_degc_to_code(int degc, int idx)
 
 static void msm_tsens_get_temp(int sensor_hw_num, unsigned long *temp)
 {
-	unsigned int code, sensor_addr, trdy_addr;
+	unsigned int code;
+	unsigned long sensor_addr, trdy_addr;
 	int sensor_sw_id = -EINVAL, rc = 0;
 
 	if (tmdev->tsens_type == TSENS_TYPE2) {
-		trdy_addr =
-			(unsigned int)TSENS2_TRDY_ADDR(
+		trdy_addr = (unsigned long)(uintptr_t)TSENS2_TRDY_ADDR(
 							tmdev->tsens_addr);
-		sensor_addr =
-			(unsigned int)TSENS2_SN_STATUS_ADDR(
+		sensor_addr = (unsigned long)(uintptr_t)TSENS2_SN_STATUS_ADDR(
 							tmdev->tsens_addr);
 	} else {
-		trdy_addr =
-			(unsigned int)TSENS_TRDY_ADDR(tmdev->tsens_addr);
-		sensor_addr =
-			(unsigned int)TSENS_S0_STATUS_ADDR(
+		trdy_addr = (unsigned long)(uintptr_t)TSENS_TRDY_ADDR(
+							tmdev->tsens_addr);
+		sensor_addr = (unsigned long)(uintptr_t)TSENS_S0_STATUS_ADDR(
 							tmdev->tsens_addr);
 	}
 
 	if (!tmdev->prev_reading_avail) {
-		while (!((readl_relaxed(trdy_addr)) & TSENS_TRDY_MASK))
+		while (!((readl_relaxed((uintptr_t)trdy_addr)) &
+					TSENS_TRDY_MASK))
 			usleep_range(TSENS_TRDY_RDY_MIN_TIME,
 				TSENS_TRDY_RDY_MAX_TIME);
 		tmdev->prev_reading_avail = true;
 	}
 
-	code = readl_relaxed(sensor_addr +
-			(sensor_hw_num << TSENS_STATUS_ADDR_OFFSET));
+	code = readl_relaxed((uintptr_t)(sensor_addr +
+			(sensor_hw_num << TSENS_STATUS_ADDR_OFFSET)));
 	/* Obtain SW index to map the corresponding thermal zone's
 	 * offset and slope for code to degc conversion. */
 	rc = tsens_get_sw_id_mapping(sensor_hw_num, &sensor_sw_id);
@@ -527,8 +545,10 @@ static int tsens_tz_get_temp(struct thermal_zone_device *thermal,
 
 int tsens_get_temp(struct tsens_device *device, unsigned long *temp)
 {
-	if (!tmdev)
-		return -ENODEV;
+	if (tsens_is_ready() <= 0) {
+		pr_debug("TSENS early init not done\n");
+		return -EPROBE_DEFER;
+	}
 
 	msm_tsens_get_temp(device->sensor_num, temp);
 
@@ -538,8 +558,10 @@ EXPORT_SYMBOL(tsens_get_temp);
 
 int tsens_get_max_sensor_num(uint32_t *tsens_num_sensors)
 {
-	if (!tmdev)
-		return -ENODEV;
+	if (tsens_is_ready() <= 0) {
+		pr_debug("TSENS early init not done\n");
+		return -EPROBE_DEFER;
+	}
 
 	*tsens_num_sensors = tmdev->tsens_num_sensor;
 
@@ -758,29 +780,30 @@ static void tsens_scheduler_fn(struct work_struct *work)
 	struct tsens_tm_device *tm = container_of(work, struct tsens_tm_device,
 						tsens_work);
 	unsigned int i, status, threshold;
-	unsigned int sensor_status_addr, sensor_status_ctrl_addr;
+	unsigned long sensor_status_addr, sensor_status_ctrl_addr;
 	int sensor_sw_id = -EINVAL, rc = 0;
 
 	if (tmdev->tsens_type == TSENS_TYPE2)
 		sensor_status_addr =
-			(unsigned int)TSENS2_SN_STATUS_ADDR(
+			(unsigned long)(uintptr_t)TSENS2_SN_STATUS_ADDR(
 							tmdev->tsens_addr);
 	else
-		sensor_status_addr =
-			(unsigned int)TSENS_S0_STATUS_ADDR(tmdev->tsens_addr);
+		sensor_status_addr = (unsigned long)(uintptr_t)
+					TSENS_S0_STATUS_ADDR(tmdev->tsens_addr);
 
 	sensor_status_ctrl_addr =
-		(unsigned int)TSENS_S0_UPPER_LOWER_STATUS_CTRL_ADDR
-		(tmdev->tsens_addr);
+		(unsigned long)(uintptr_t)TSENS_S0_UPPER_LOWER_STATUS_CTRL_ADDR
+							(tmdev->tsens_addr);
 	for (i = 0; i < tm->tsens_num_sensor; i++) {
 		bool upper_thr = false, lower_thr = false;
 		uint32_t addr_offset;
 
 		addr_offset = tm->sensor[i].sensor_hw_num *
 						TSENS_SN_ADDR_OFFSET;
-		status = readl_relaxed(sensor_status_addr + addr_offset);
-		threshold = readl_relaxed(sensor_status_ctrl_addr +
-								addr_offset);
+		status = readl_relaxed((uintptr_t)
+					(sensor_status_addr + addr_offset));
+		threshold = readl_relaxed((uintptr_t)(sensor_status_ctrl_addr +
+								addr_offset));
 		if (status & TSENS_SN_STATUS_UPPER_STATUS) {
 			writel_relaxed(threshold | TSENS_UPPER_STATUS_CLR,
 				TSENS_S0_UPPER_LOWER_STATUS_CTRL_ADDR(
@@ -965,7 +988,7 @@ static int tsens_calib_8916_sensors(void)
 	}
 
 	if (tsens_calibration_mode == TSENS_TWO_POINT_CALIB) {
-		pr_info("two point calibration calculation\n");
+		pr_debug("two point calibration calculation\n");
 		calib_tsens_point2_data[0] =
 			((tsens_base1_data + tsens0_point2) << 3);
 		calib_tsens_point2_data[1] =
@@ -2070,7 +2093,7 @@ static int get_device_tree_data(struct platform_device *pdev)
 				"qcom,calibration-less-mode");
 	tmdev->tsens_local_init = of_property_read_bool(of_node,
 				"qcom,tsens-local-init");
-	tmdev->calib_mode = (u32) id->data;
+	tmdev->calib_mode = (u32)(uintptr_t) id->data;
 
 	sensor_id = devm_kzalloc(&pdev->dev,
 		tsens_num_sensors * sizeof(u32), GFP_KERNEL);
@@ -2218,6 +2241,8 @@ static int tsens_tm_probe(struct platform_device *pdev)
 
 	tmdev->prev_reading_avail = true;
 
+	tmdev->is_ready = true;
+
 	platform_set_drvdata(pdev, tmdev);
 
 	return 0;
@@ -2246,7 +2271,7 @@ static int _tsens_register_thermal(void)
 	struct platform_device *pdev;
 	int rc, i;
 
-	if (!tmdev) {
+	if (tsens_is_ready() <= 0) {
 		pr_err("%s: TSENS early init not done\n", __func__);
 		return -ENODEV;
 	}
@@ -2340,6 +2365,7 @@ int __init tsens_tm_init_driver(void)
 {
 	return platform_driver_register(&tsens_tm_driver);
 }
+arch_initcall(tsens_tm_init_driver);
 
 static int __init tsens_thermal_register(void)
 {
diff --git a/drivers/thermal/msm_thermal.c b/drivers/thermal/msm_thermal.c
index f27fde4..09cceb5 100644
--- a/drivers/thermal/msm_thermal.c
+++ b/drivers/thermal/msm_thermal.c
@@ -2470,7 +2470,17 @@ int msm_thermal_pre_init(void)
 {
 	int ret = 0;
 
-	tsens_get_max_sensor_num(&max_tsens_num);
+	if (tsens_is_ready() <= 0) {
+		pr_err("Tsens driver is not ready yet\n");
+		return -EPROBE_DEFER;
+	}
+
+	ret = tsens_get_max_sensor_num(&max_tsens_num);
+	if (ret < 0) {
+		pr_err("failed to get max sensor number, err:%d\n", ret);
+		return ret;
+	}
+
 	if (create_sensor_id_map()) {
 		pr_err("Creating sensor id map failed\n");
 		ret = -EINVAL;
@@ -3372,6 +3382,7 @@ int __init msm_thermal_device_init(void)
 {
 	return platform_driver_register(&msm_thermal_device_driver);
 }
+arch_initcall(msm_thermal_device_init);
 
 int __init msm_thermal_late_init(void)
 {
diff --git a/include/linux/msm_tsens.h b/include/linux/msm_tsens.h
index 5e477b1..3dfe78b 100644
--- a/include/linux/msm_tsens.h
+++ b/include/linux/msm_tsens.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -43,10 +43,13 @@ int32_t tsens_get_temp(struct tsens_device *dev, unsigned long *temp);
 int msm_tsens_early_init(struct tsens_platform_data *pdata);
 
 #if defined(CONFIG_THERMAL_TSENS8974)
+int tsens_is_ready(void);
 int __init tsens_tm_init_driver(void);
 int tsens_get_sw_id_mapping(int sensor_num, int *sensor_sw_idx);
 int tsens_get_hw_id_mapping(int sensor_sw_id, int *sensor_hw_num);
 #else
+static inline int tsens_is_ready(void)
+{ return -ENXIO; }
 static inline int __init tsens_tm_init_driver(void)
 { return -ENXIO; }
 static inline int tsens_get_sw_id_mapping(
