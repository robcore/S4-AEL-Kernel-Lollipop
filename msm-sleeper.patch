From aef0ccc7065b257dafa76972b6d8280352ac2688 Mon Sep 17 00:00:00 2001
From: flar2 <asegaert@gmail.com>
Date: Sun, 24 Nov 2013 00:37:14 -0500
Subject: [PATCH] Max screen off frequency (default 1026MHz)

Signed-off-by: flar2 <asegaert@gmail.com>
---
 arch/arm/mach-msm/Kconfig       |  6 +++
 arch/arm/mach-msm/Makefile      |  1 +
 arch/arm/mach-msm/cpufreq.c     | 95 +++++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-msm/msm-sleeper.c | 84 ++++++++++++++++++++++++++++++++++++
 4 files changed, 186 insertions(+)
 create mode 100644 arch/arm/mach-msm/msm-sleeper.c

diff --git a/arch/arm/mach-msm/Kconfig b/arch/arm/mach-msm/Kconfig
index 17ed2db..1b85cfd 100644
--- a/arch/arm/mach-msm/Kconfig
+++ b/arch/arm/mach-msm/Kconfig
@@ -1629,6 +1629,12 @@ config MSM_CPU_FREQ_MIN
 
 endif # CPU_FREQ_MSM
 
+config MSM_SLEEPER
+	bool "Limit max frequency while screen is off"
+	default y
+	help
+	  Limit max frequency while screen is off
+
 config CPU_VOLTAGE_TABLE
 	bool "Enable CPU Voltage Table via sysfs for adjustements"
 	default n
diff --git a/arch/arm/mach-msm/cpufreq.c b/arch/arm/mach-msm/cpufreq.c
index 0662726..e988a30 100644
--- a/arch/arm/mach-msm/cpufreq.c
+++ b/arch/arm/mach-msm/cpufreq.c
@@ -43,6 +43,10 @@ struct cpufreq_work_struct {
 static DEFINE_PER_CPU(struct cpufreq_work_struct, cpufreq_work);
 static struct workqueue_struct *msm_cpufreq_wq;
 
+/* maxscroff */
+uint32_t maxscroff_freq = 1026000;
+uint32_t maxscroff = 1;
+
 struct cpufreq_suspend_t {
 	struct mutex suspend_mutex;
 	int device_suspended;
@@ -60,6 +64,22 @@ struct cpu_freq {
 
 static DEFINE_PER_CPU(struct cpu_freq, cpu_freq_info);
 
+/**maxscroff**/
+static int __init cpufreq_read_arg_maxscroff(char *max_so)
+{
+	if (strcmp(max_so, "0") == 0) {
+		maxscroff = 0;
+	} else if (strcmp(max_so, "1") == 0) {
+		maxscroff = 1;
+	} else {
+		maxscroff = 0;
+	}
+	return 1;
+}
+
+__setup("max_so=", cpufreq_read_arg_maxscroff);
+/**end maxscroff**/
+
 static int set_cpu_freq(struct cpufreq_policy *policy, unsigned int new_freq)
 {
 	int ret = 0;
@@ -355,8 +375,83 @@ static int msm_cpufreq_resume(struct cpufreq_policy *policy)
 	return 0;
 }
 
+/** maxscreen off sysfs interface **/
+
+static ssize_t show_max_screen_off_khz(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", maxscroff_freq);
+}
+
+static ssize_t store_max_screen_off_khz(struct cpufreq_policy *policy,
+		const char *buf, size_t count)
+{
+	unsigned int freq = 0;
+	int ret;
+	int index;
+	struct cpufreq_frequency_table *freq_table = cpufreq_frequency_get_table(policy->cpu);
+
+	if (!freq_table)
+		return -EINVAL;
+
+	ret = sscanf(buf, "%u", &freq);
+	if (ret != 1)
+		return -EINVAL;
+
+	mutex_lock(&per_cpu(cpufreq_suspend, policy->cpu).suspend_mutex);
+
+	ret = cpufreq_frequency_table_target(policy, freq_table, freq,
+			CPUFREQ_RELATION_H, &index);
+	if (ret)
+		goto out;
+
+	maxscroff_freq = freq_table[index].frequency;
+
+	ret = count;
+
+out:
+	mutex_unlock(&per_cpu(cpufreq_suspend, policy->cpu).suspend_mutex);
+	return ret;
+}
+
+struct freq_attr msm_cpufreq_attr_max_screen_off_khz = {
+	.attr = { .name = "screen_off_max_freq",
+		.mode = 0644,
+	},
+	.show = show_max_screen_off_khz,
+	.store = store_max_screen_off_khz,
+};
+
+static ssize_t show_max_screen_off(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", maxscroff);
+}
+
+static ssize_t store_max_screen_off(struct cpufreq_policy *policy,
+		const char *buf, size_t count)
+{
+	if (buf[0] >= '0' && buf[0] <= '1' && buf[1] == '\n')
+            if (maxscroff != buf[0] - '0') 
+		        maxscroff = buf[0] - '0';
+
+	return count;
+}
+
+struct freq_attr msm_cpufreq_attr_max_screen_off = {
+	.attr = { .name = "screen_off_max",
+		.mode = 0644,
+	},
+	.show = show_max_screen_off,
+	.store = store_max_screen_off,
+};
+
+/** end maxscreen off sysfs interface **/
+
+
 static struct freq_attr *msm_freq_attr[] = {
 	&cpufreq_freq_attr_scaling_available_freqs,
+/** maxscreen off sysfs interface **/
+	&msm_cpufreq_attr_max_screen_off_khz,
+	&msm_cpufreq_attr_max_screen_off,
 	NULL,
 };
 
diff --git a/arch/arm/mach-msm/msm-sleeper.c b/arch/arm/mach-msm/msm-sleeper.c
new file mode 100644
index 0000000..91ba847
--- /dev/null
+++ b/arch/arm/mach-msm/msm-sleeper.c
@@ -0,0 +1,84 @@
+/*
+ * ElementalX msm-sleeper by flar2 <asegaert@gmail.com>
+ * 
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/workqueue.h>
+#include <linux/cpu.h>
+#include <linux/module.h>
+#include <linux/cpufreq.h>
+#include <mach/cpufreq.h>
+
+#define MSM_SLEEPER_MAJOR_VERSION	1
+#define MSM_SLEEPER_MINOR_VERSION	1
+
+extern uint32_t maxscroff;
+extern uint32_t maxscroff_freq;
+static int limit_set = 0;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void msm_sleeper_early_suspend(struct early_suspend *h)
+{
+	int cpu;
+
+	if (maxscroff) {
+		for_each_possible_cpu(cpu) {
+			msm_cpufreq_set_freq_limits(cpu, MSM_CPUFREQ_NO_LIMIT, maxscroff_freq);
+			pr_info("msm-sleeper: limit max frequency to: %d\n", maxscroff_freq);
+		}
+		limit_set = 1;
+	}
+	return; 
+}
+
+static void msm_sleeper_late_resume(struct early_suspend *h)
+{
+	int cpu;
+
+	if (!limit_set)
+		return;
+
+	for_each_possible_cpu(cpu) {
+		msm_cpufreq_set_freq_limits(cpu, MSM_CPUFREQ_NO_LIMIT, MSM_CPUFREQ_NO_LIMIT);
+		pr_info("msm-sleeper: restore max frequency.\n");
+	}
+	limit_set = 0;
+	return; 
+}
+
+static struct early_suspend msm_sleeper_early_suspend_driver = {
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 10,
+	.suspend = msm_sleeper_early_suspend,
+	.resume = msm_sleeper_late_resume,
+};
+#endif
+
+static int __init msm_sleeper_init(void)
+{
+	pr_info("msm-sleeper version %d.%d\n",
+		 MSM_SLEEPER_MAJOR_VERSION,
+		 MSM_SLEEPER_MINOR_VERSION);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	register_early_suspend(&msm_sleeper_early_suspend_driver);
+#endif
+	return 0;
+}
+
+MODULE_AUTHOR("flar2 <asegaert at gmail.com>");
+MODULE_DESCRIPTION("'msm-sleeper' - Limit max frequency while screen is off");
+MODULE_LICENSE("GPL");
+
+late_initcall(msm_sleeper_init);
+
