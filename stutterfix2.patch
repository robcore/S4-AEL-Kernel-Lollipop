commit	139be050f692d12cc868da186001916fb4408b9e	[log] [tgz]
author	Cheng-Yi Chiang <cychiang@chromium.org>	Mon Nov 10 16:12:47 2014
committer	chrome-internal-fetch <chrome-internal-fetch@google.com>	Thu Dec 18 08:36:11 2014
tree	2d6a72c17b69547880416ee1e50702f805b01cfe
parent	948f7731bdfac0085afa69b8f5c25052193752d6 [diff]

max98090: Shutdown codec before updating some registers

According to user manual, there are some registers whose change requires
shutdown bit = 0. This patch adds shutdown call before updating those
registers. The codec state will be restored after the update.

In max98090_dai_hw_params, codec might get new lrclk and pcm format.
If pcm format is changed, or needs to be set for the first time,
it needs a shutdown.
If lrclk is changed, or needs to be set for the first time, it needs a
shutdown.
If sysclk is changed, it needs a shutdown.

Apart from the registers listed on user manual, DMIC should be toggled
when codec is off. However, in reality, it is fine to enable DMIC when
codec is on, as long as there is an extra shutdown/restore after DMIC is
enabled.
This patch adds an event callback to DAPM supply widget DMICL_ENA and
DMICR_ENA so DAPM will shutdown codec before DMIC is enabled.
After DMIC is enabled, it does another shutdown/restore since shutdown
register is not protected in the time frame between PRE_PMU and POST_PMU
events.
Note that this is only required for max98090, not max98091.

In methods other than dmic_event, the code to shutdown codec, update
registers, and turn on codec are protected by a mutex in private data to
make sure codec is in shutdown state when register is being updated.

With this patch, there will be no audio drop in playback stream when
capture stream starts to use external mic. There will be audio drop in
playback stream when capture stream starts to use digital mic.

To avoid the playback stream audio drop, dmic can be enabled in all
playback cases, which will be handled in machine driver by adding DAPM
routes.

BUG=chromium:415156
TEST=On peach_pit (using max98090), record using external mic while
playing audio. There will be NO audio drop. Check recorded audio is fine.
TEST=On peach_pit (using max98090), record using internal mic while
playing audio. There will be audio drop. Check recorded audio is fine.
TEST=On peach_pi (using max98091), record using external mic while
playing audio. There will be NO audio drop. Check recorded audio is fine.
TEST=On peach_pi (using max98091), record using internal mic while
playing audio. There will be NO audio drop. Check recorded audio is fine.

Change-Id: I7a8986e70890e6dd39949866958bc9aa90427b32
Signed-off-by: Cheng-Yi Chiang <cychiang@chromium.org>
Reviewed-on: https://chromium-review.googlesource.com/232355

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 21eab9a..48fd2f8d 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c

@@ -839,43 +839,100 @@
 	return 0;
 }

-/* Save state when temporarily shutting down the codec to change registers that
- * must only be changes while in software shutdown.
- */
-struct max98090_shdn_state {
-	int old_shdn;
-	int old_level_control;
-};
-
-static void max98090_shdn_save(struct snd_soc_codec *codec,
-			       struct max98090_shdn_state *state)
+/* Save state and shutdown codec. */
+static void max98090_shdn_save(struct snd_soc_codec *codec)
 {
-	regmap_read(codec->control_data, M98090_REG_DEVICE_SHUTDOWN,
-			&state->old_shdn);
-	if (state->old_shdn & M98090_SHDNN_MASK) {
-		regmap_read(codec->control_data,
-			M98090_REG_LEVEL_CONTROL, &state->old_level_control);
+	unsigned int shutdown_reg;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	regmap_read(max98090->regmap, M98090_REG_DEVICE_SHUTDOWN,
+			&shutdown_reg);
+	/* Shutdown only if needed. */
+	if (shutdown_reg & M98090_SHDNN_MASK) {
+		/* Only save state if state is not saved before. */
+		if (!max98090->state.saved) {
+			regmap_read(max98090->regmap,
+				M98090_REG_LEVEL_CONTROL,
+				&max98090->state.old_level_control);
+			max98090->state.old_shdn = shutdown_reg;
+			max98090->state.saved = 1;
+		}
+
 		/* Enable volume smoothing, disable zero cross.  This will cause
 		 * a quick 40ms ramp to mute on shutdown.
 		 */
-		regmap_write(codec->control_data,
+		regmap_write(max98090->regmap,
 			M98090_REG_LEVEL_CONTROL, M98090_VSENN_MASK);
-		regmap_write(codec->control_data,
+		regmap_write(max98090->regmap,
 			M98090_REG_DEVICE_SHUTDOWN, 0x00);
+		regcache_mark_dirty(max98090->regmap);
 		msleep(40);
 	}
 }

-static void max98090_shdn_restore(struct snd_soc_codec *codec,
-				  struct max98090_shdn_state *state)
+static void max98090_shdn_restore(struct snd_soc_codec *codec)
 {
-	if (state->old_shdn & M98090_SHDNN_MASK) {
-		regmap_write(codec->control_data,
-			M98090_REG_LEVEL_CONTROL, state->old_level_control);
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	if (!max98090->state.saved)
+		return;
+
+	/* Turn on codec and restore level control if it was on. */
+	if (max98090->state.old_shdn & M98090_SHDNN_MASK) {
+		regmap_write(max98090->regmap,
+			M98090_REG_LEVEL_CONTROL,
+			max98090->state.old_level_control);
 		mdelay(1); /* Let input path stablize before releasing shdn. */
-		regmap_write(codec->control_data,
-			M98090_REG_DEVICE_SHUTDOWN, state->old_shdn);
+		regmap_write(max98090->regmap,
+			M98090_REG_DEVICE_SHUTDOWN, max98090->state.old_shdn);
+		regcache_sync(max98090->regmap);
+		/* Clear saved state. */
+		max98090->state.saved = 0;
 	}
+}
+
+/*
+ * On max98090, DMIC should be enabled when shutdown bit is 0.
+ * However, DAPM does not support customizing procedure to
+ * shutdown codec, update a register, and turn on codec.
+ * In PRE_PMU case, we shutdown codec. After that before POST_PMU,
+ * the shutdown register is not protected. In reality, an extra
+ * shutdown and restore after DMIC is enabled is good enough to make
+ * DMIC works properly even if codec was on when DMIC was turned on.
+ * Max98091 is not subjected to this issue.
+ */
+static int dmic_event(struct snd_soc_dapm_widget *w,
+			 struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	if (max98090->devtype == MAX98091)
+		return 0;
+
+	switch (event) {
+	/* Shutdown codec */
+	case SND_SOC_DAPM_PRE_PMU:
+		mutex_lock(&max98090->mutex);
+		max98090_shdn_save(codec);
+		mutex_unlock(&max98090->mutex);
+		max98090->dmic_post_pmu_done = false;
+		break;
+	/* Shutdown and resotre codec. Use the flag dmic_post_pmu_done to
+	 * save one shutdown/restore cycle because DMICL_ENA and DMICR_ENA
+	 * shares this callback. */
+	case SND_SOC_DAPM_POST_PMU:
+		if (max98090->dmic_post_pmu_done)
+			return 0;
+		mutex_lock(&max98090->mutex);
+		max98090_shdn_save(codec);
+		max98090_shdn_restore(codec);
+		mutex_unlock(&max98090->mutex);
+		max98090->dmic_post_pmu_done = true;
+		break;
+	}
+
+	return 0;
 }

 static const char *mic1_mux_text[] = { "IN12", "IN56" };
@@ -1184,9 +1241,11 @@
 	SND_SOC_DAPM_SUPPLY("SDOEN", M98090_REG_IO_CONFIGURATION,
 		M98090_SDOEN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("DMICL_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMICL_SHIFT, 0, NULL, 0),
+		 M98090_DIGMICL_SHIFT, 0, dmic_event,
+		 SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("DMICR_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMICR_SHIFT, 0, NULL, 0),
+		 M98090_DIGMICR_SHIFT, 0, dmic_event,
+		 SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("AHPF", M98090_REG_FILTER_CONFIG,
 		M98090_AHPF_SHIFT, 0, NULL, 0),

@@ -1681,11 +1740,15 @@
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	struct max98090_cdata *cdata;
 	u8 regval;
+	int ret = 0;

 	max98090->dai_fmt = fmt;
 	cdata = &max98090->dai[0];

 	if (fmt != cdata->fmt) {
+		mutex_lock(&max98090->mutex);
+		/* Shutdown to config clock mode. */
+		max98090_shdn_save(codec);
 		cdata->fmt = fmt;

 		regval = 0;
@@ -1719,7 +1782,8 @@
 		case SND_SOC_DAIFMT_CBM_CFS:
 		default:
 			dev_err(codec->dev, "DAI clock mode unsupported");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto exit_reset_shdn;
 		}
 		snd_soc_write(codec, M98090_REG_MASTER_MODE, regval);

@@ -1737,7 +1801,8 @@
 			/* Not supported mode */
 		default:
 			dev_err(codec->dev, "DAI format unsupported");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto exit_reset_shdn;
 		}

 		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
@@ -1754,7 +1819,8 @@
 			break;
 		default:
 			dev_err(codec->dev, "DAI invert mode unsupported");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto exit_reset_shdn;
 		}

 		/*
@@ -1770,7 +1836,10 @@
 			M98090_REG_INTERFACE_FORMAT, regval);
 	}

-	return 0;
+exit_reset_shdn:
+	max98090_shdn_restore(codec);
+	mutex_unlock(&max98090->mutex);
+	return ret;
 }

 static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
@@ -1818,6 +1887,10 @@
 	switch (level) {
 	case SND_SOC_BIAS_ON:
 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			mutex_lock(&max98090->mutex);
+			snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+			mutex_unlock(&max98090->mutex);
 			ret = regcache_sync(max98090->regmap);

 			if (ret != 0) {
@@ -1844,10 +1917,15 @@
 		/* Set internal pull-up to lowest power mode */
 		snd_soc_update_bits(codec, M98090_REG_JACK_DETECT,
 			M98090_JDWK_MASK, M98090_JDWK_MASK);
+		mutex_lock(&max98090->mutex);
+		snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, 0);
+		mutex_unlock(&max98090->mutex);
 		regcache_mark_dirty(max98090->regmap);
 		break;
 	}
 	codec->dapm.bias_level = level;
+
 	return 0;
 }

@@ -1880,19 +1958,28 @@
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	struct max98090_cdata *cdata;
 	int i, j;
-	struct max98090_shdn_state state;
+	unsigned int new_lrclk = params_rate(params);
+	snd_pcm_format_t new_pcm_format = params_format(params);
+	bool lrclk_changed = (new_lrclk != max98090->lrclk);
+	bool format_changed = (new_pcm_format != max98090->pcm_format);
 	int ret = 0;

-	max98090_shdn_save(codec, &state);
+	max98090->lrclk = new_lrclk;
+	max98090->pcm_format = new_pcm_format;

 	cdata = &max98090->dai[0];
 	max98090->bclk = snd_soc_params_to_bclk(params);
 	if (params_channels(params) == 1)
 		max98090->bclk *= 2;

-	max98090->lrclk = params_rate(params);
+	/* Checks if we needs to shutdown and config format, clock or mode. */
+	if (!lrclk_changed && !format_changed && !max98090->sysclk_changed)
+		return 0;

-	switch (params_format(params)) {
+	mutex_lock(&max98090->mutex);
+	max98090_shdn_save(codec);
+
+	switch (max98090->pcm_format) {
 	case SNDRV_PCM_FORMAT_S16_LE:
 		snd_soc_update_bits(codec, M98090_REG_INTERFACE_FORMAT,
 			M98090_WS_MASK, 0);
@@ -1944,9 +2031,15 @@
 			M98090_DMIC_COMP_MASK,
 			dmic_comp[j][i] << M98090_DMIC_COMP_SHIFT);

+	/* Mark that the sysclk change which results in pclk change, dmic
+	 * configuration change, and bclk configuration change have been
+	 * handled. */
+	max98090->sysclk_changed = false;
+

 exit_reset_shdn:
-	max98090_shdn_restore(codec, &state);
+	max98090_shdn_restore(codec);
+	mutex_unlock(&max98090->mutex);
 	return ret;
 }

@@ -1958,10 +2051,18 @@
 {
 	struct snd_soc_codec *codec = dai->codec;
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;

 	/* Requested clock frequency is already setup */
 	if (freq == max98090->sysclk)
 		return 0;
+
+	/*
+	 * sysclk is not set before. Shutdown codec and set system clock
+	 * registers.
+	 */
+	mutex_lock(&max98090->mutex);
+	max98090_shdn_save(codec);

 	/* Setup clocks for slave mode, and using the PLL
 	 * PSCLK = 0x01 (when master clk is 10MHz to 20MHz)
@@ -1979,14 +2080,19 @@
 			M98090_PSCLK_DIV4);
 	} else {
 		dev_err(codec->dev, "Invalid master clock frequency\n");
-		return -EINVAL;
+		ret = -EINVAL;
+		goto exit_reset_shdn;
 	}

 	max98090->sysclk = freq;
+	max98090->sysclk_changed = true;

 	max98090_configure_bclk(codec);

-	return 0;
+exit_reset_shdn:
+	max98090_shdn_restore(codec);
+	mutex_unlock(&max98090->mutex);
+	return ret;
 }

 static int max98090_dai_digital_mute(struct snd_soc_dai *codec_dai, int mute)
@@ -2088,6 +2194,7 @@
 			    SND_JACK_HEADSET | SND_JACK_BTN_0);

 	snd_soc_dapm_sync(dapm);
+
 }

 static irqreturn_t max98090_interrupt(int irq, void *data)
@@ -2263,6 +2370,11 @@
 	/* Initialize private data */

 	max98090->sysclk = (unsigned)-1;
+	max98090->sysclk_changed = false;
+	max98090->pcm_format = (unsigned)-1;
+	max98090->dmic_post_pmu_done = false;
+	max98090->state.saved = 0;
+	mutex_init(&max98090->mutex);

 	cdata = &max98090->dai[0];
 	cdata->rate = (unsigned)-1;

diff --git a/sound/soc/codecs/max98090.h b/sound/soc/codecs/max98090.h
index 7e103f2..0a4bfb5 100644
--- a/sound/soc/codecs/max98090.h
+++ b/sound/soc/codecs/max98090.h

@@ -12,6 +12,7 @@
 #define _MAX98090_H

 #include <linux/version.h>
+#include <linux/mutex.h>

 /* One can override the Linux version here with an explicit version number */
 #define M98090_LINUX_VERSION LINUX_VERSION_CODE
@@ -1519,6 +1520,15 @@
 	unsigned int fmt;
 };

+/* Save state when temporarily shutting down the codec to change registers that
+ * must only be changes while in software shutdown.
+ */
+struct max98090_shdn_state {
+	int old_shdn;
+	int old_level_control;
+	bool saved;
+};
+
 struct max98090_priv {
 	struct regmap *regmap;
 	struct snd_soc_codec *codec;
@@ -1541,6 +1551,11 @@
 	unsigned int pa2en;
 	unsigned int extmic_mux;
 	unsigned int sidetone;
+	bool sysclk_changed;
+	snd_pcm_format_t pcm_format;
+	struct mutex mutex;
+	struct max98090_shdn_state state;
+	bool dmic_post_pmu_done;
 };

 int max98090_mic_detect(struct snd_soc_codec *codec,
