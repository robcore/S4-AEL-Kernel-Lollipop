From 422099d3ef7cc3734ccba51f1273a136242a26f2 Mon Sep 17 00:00:00 2001
From: shminer <332574643@qq.com>
Date: Tue, 16 Jun 2015 14:30:02 +0800
Subject: [PATCH] add last alcuard intellithermal

---
 arch/arm/configs/JZ_f460_defconfig |   4 +-
 drivers/thermal/msm_thermal.c      | 524 +++++++++++++++++++++++++++----------
 include/linux/msm_thermal.h        |  12 +
 3 files changed, 400 insertions(+), 140 deletions(-)

diff --git a/arch/arm/configs/JZ_f460_defconfig b/arch/arm/configs/JZ_f460_defconfig
index d6d28f5..e83279f 100644
--- a/arch/arm/configs/JZ_f460_defconfig
+++ b/arch/arm/configs/JZ_f460_defconfig
@@ -2476,8 +2476,8 @@ CONFIG_THERMAL_GOV_STEP_WISE=y
 # CONFIG_CPU_THERMAL is not set
 # CONFIG_THERMAL_EMULATION is not set
 CONFIG_THERMAL_TSENS8974=y
-# CONFIG_THERMAL_MONITOR is not set
-CONFIG_INTELLI_THERMAL=y
+CONFIG_THERMAL_MONITOR=y
+# CONFIG_INTELLI_THERMAL is not set
 CONFIG_THERMAL_QPNP=y
 CONFIG_THERMAL_QPNP_ADC_TM=y
 # CONFIG_WATCHDOG is not set
diff --git a/drivers/thermal/msm_thermal.c b/drivers/thermal/msm_thermal.c
index b069939..726c770 100644
--- a/drivers/thermal/msm_thermal.c
+++ b/drivers/thermal/msm_thermal.c
@@ -9,6 +9,11 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
+ * Added code to work as a standalone intelligent thermal throttling driver
+ * for many Qualcomm SOCs by Paul Reioux (Faux123)
+ * Merged with MSM Thermal code by Yuri Sh. (Dorimanx)
+ * Modifications copyright (c) 2014
+ *
  */
 
 #define pr_fmt(fmt) "%s:%s " fmt, KBUILD_MODNAME, __func__
@@ -33,6 +38,7 @@
 #include <linux/sysfs.h>
 #include <linux/types.h>
 #include <linux/thermal.h>
+#include <linux/sched/rt.h>
 #include <mach/rpm-regulator.h>
 #include <linux/regulator/rpm-smd-regulator.h>
 #include <linux/regulator/consumer.h>
@@ -46,10 +52,43 @@
 #define TSENS_NAME_MAX 20
 #define TSENS_NAME_FORMAT "tsens_tz_sensor%d"
 #define THERM_SECURE_BITE_CMD 8
+#define CORE_MAX_FREQ 2880000
+
+#define DEFAULT_POLLING_MS	250
+
+#ifdef CONFIG_INTELLI_THERMAL_STATS
+/* last 3 minutes based on $DEFAULT_POLLING_MS polling cycle */
+#define MAX_HISTORY_SZ		((3*60*1000) / DEFAULT_POLLING_MS)
+
+struct msm_thermal_stat_data {
+	int32_t temp_history[MAX_HISTORY_SZ];
+	uint32_t throttled;
+	uint32_t warning;
+	uint32_t normal;
+};
+static struct msm_thermal_stat_data msm_thermal_stats;
+static uint32_t hist_index = 0;
+#endif
 
 static struct msm_thermal_data msm_thermal_info;
+
+static struct msm_thermal_data_intelli msm_thermal_info_local = {
+	.sensor_id = 0,
+	.poll_ms = DEFAULT_POLLING_MS,
+	.limit_temp_degC = 75,
+	.temp_hysteresis_degC = 10,
+	.freq_step = 2,
+	.freq_control_mask = 0xf,
+	.core_limit_temp_degC = 80,
+	.core_temp_hysteresis_degC = 5,
+	.core_control_mask = 0xe,
+};
+
 static struct delayed_work check_temp_work;
-static bool core_control_enabled;
+bool core_control;
+/* dummy parameter for rom thermal and apps */
+static bool enabled = 1;
+static unsigned int debug_mode = 0;
 static uint32_t cpus_offlined;
 static DEFINE_MUTEX(core_control_mutex);
 static struct kobject *cc_kobj;
@@ -60,14 +99,22 @@ static struct completion hotplug_notify_complete;
 static struct completion freq_mitigation_complete;
 static struct completion thermal_monitor_complete;
 
-static int enabled;
-static int polling_enabled;
+/* Always enable Intelli Thermal on boot */
+static int intelli_enabled;
+
 static int rails_cnt;
 static int psm_rails_cnt;
 static int limit_idx;
-static int limit_idx_low;
+/*
+ * min limit is set to 1497600 Mhz!
+ * check your FREQ Table and set corect limit_idx_low freq number.
+ * thanks git@dorimanx
+ */
+static int limit_idx_low = 9;
 static int limit_idx_high;
+static int max_idx;
 static int max_tsens_num;
+static bool immediately_limit_stop = false;
 static struct cpufreq_frequency_table *table;
 static uint32_t usefreq;
 static int freq_table_get;
@@ -255,6 +302,56 @@ enum PMIC_SW_MODE {
 	sysfs_attr_init(&_attr.attr); \
 	_attr_gr.attrs[j] = &_attr.attr;
 
+#define DEFAULT_POLLING_MS     250
+/* last 3 minutes based on 250ms polling cycle */
+#define MAX_HISTORY_SZ         ((3*60*1000) / DEFAULT_POLLING_MS)
+
+struct msm_thermal_stat_data {
+	int32_t temp_history[MAX_HISTORY_SZ];
+	uint32_t throttled;
+	uint32_t warning;
+	uint32_t normal;
+};
+
+/* module parameters */
+module_param_named(poll_ms, msm_thermal_info_local.poll_ms, uint, 0664);
+module_param_named(limit_temp_degC, msm_thermal_info_local.limit_temp_degC,
+			int, 0664);
+module_param_named(temp_hysteresis_degC,
+			msm_thermal_info_local.temp_hysteresis_degC,
+			int, 0664);
+module_param_named(freq_step, msm_thermal_info_local.freq_step,
+			int, 0664);
+module_param_named(immediately_limit_stop, immediately_limit_stop,
+			bool, 0664);
+module_param_named(core_limit_temp_degC,
+			msm_thermal_info_local.core_limit_temp_degC,
+			int, 0664);
+module_param_named(core_temp_hysteresis_degC,
+			msm_thermal_info_local.core_temp_hysteresis_degC,
+			int, 0664);
+module_param_named(freq_control_mask, msm_thermal_info_local.freq_control_mask,
+			uint, 0664);
+module_param_named(core_control_mask, msm_thermal_info_local.core_control_mask,
+			uint, 0664);
+
+module_param_named(thermal_limit_high, limit_idx_high, int, 0664);
+module_param_named(thermal_limit_low, limit_idx_low, int, 0664);
+
+module_param_named(thermal_debug_mode, debug_mode, int, 0664);
+
+static unsigned int safety = 1;
+module_param_named(temp_safety, safety, int, 0664);
+
+static unsigned int freq_debug = 0;
+module_param_named(freq_debug, freq_debug, uint, 0644);
+
+#define dprintk(msg...)		\
+do {				\
+	if (freq_debug)		\
+		pr_info(msg);	\
+} while (0)
+
 static int  msm_thermal_cpufreq_callback(struct notifier_block *nfb,
 		unsigned long event, void *data)
 {
@@ -333,7 +430,8 @@ static int update_cpu_min_freq_all(uint32_t min)
 		get_online_cpus();
 		for_each_possible_cpu(cpu) {
 			cpus[cpu].limited_min_freq = min;
-			update_cpu_freq(cpu);
+			if (cpufreq_update_policy(cpu))
+				pr_info("Unable to update policy for cpu:%d\n", cpu);
 		}
 		put_online_cpus();
 	}
@@ -862,8 +960,7 @@ static int msm_thermal_get_freq_table(void)
 	while (table[i].frequency != CPUFREQ_TABLE_END)
 		i++;
 
-	limit_idx_low = 0;
-	limit_idx_high = limit_idx = i - 1;
+	limit_idx_high = limit_idx = max_idx = i - 1;
 	BUG_ON(limit_idx_high <= 0 || limit_idx_high <= limit_idx_low);
 fail:
 	return ret;
@@ -1068,35 +1165,47 @@ static void __ref do_core_control(long temp)
 	int i = 0;
 	int ret = 0;
 
-	if (!core_control_enabled)
+	if (!core_control)
 		return;
 
+	/**
+	 *  Offline cores starting from the max MPIDR to 1, when above limit,
+	 *  The core control mask is non zero and allows the core to be turned
+	 *  off.
+	 *  The core was not previously offlined by this module
+	 *  The core is the next in sequence.
+	 *  If the core was online for some reason, even after it was offlined
+	 *  by this module, offline it again.
+	 *  Online the back on if the temp is below the hysteresis and was
+	 *  offlined by this module and not already online.
+	 */
 	mutex_lock(&core_control_mutex);
-	if (msm_thermal_info.core_control_mask &&
-		temp >= msm_thermal_info.core_limit_temp_degC) {
+	if (msm_thermal_info_local.core_control_mask &&
+		temp >= msm_thermal_info_local.core_limit_temp_degC) {
 		for (i = num_possible_cpus(); i > 0; i--) {
-			if (!(msm_thermal_info.core_control_mask & BIT(i)))
+			if (!(msm_thermal_info_local.core_control_mask &
+					BIT(i)))
 				continue;
 			if (cpus_offlined & BIT(i) && !cpu_online(i))
 				continue;
-			pr_info("Set Offline: CPU%d Temp: %ld\n",
-					i, temp);
+			dprintk("%s: Set Offline: CPU%d Temp: %ld\n",
+					KBUILD_MODNAME, i, temp);
 			ret = cpu_down(i);
 			if (ret)
-				pr_err("Error %d offline core %d\n",
-					ret, i);
+				pr_err("%s: Error %d offline core %d\n",
+					KBUILD_MODNAME, ret, i);
 			cpus_offlined |= BIT(i);
 			break;
 		}
-	} else if (msm_thermal_info.core_control_mask && cpus_offlined &&
-		temp <= (msm_thermal_info.core_limit_temp_degC -
-			msm_thermal_info.core_temp_hysteresis_degC)) {
+	} else if (msm_thermal_info_local.core_control_mask && cpus_offlined &&
+		temp <= (msm_thermal_info_local.core_limit_temp_degC -
+			msm_thermal_info_local.core_temp_hysteresis_degC)) {
 		for (i = 0; i < num_possible_cpus(); i++) {
 			if (!(cpus_offlined & BIT(i)))
 				continue;
 			cpus_offlined &= ~BIT(i);
-			pr_info("Allow Online CPU%d Temp: %ld\n",
-					i, temp);
+			dprintk("%s: Allow Online CPU%d Temp: %ld\n",
+					KBUILD_MODNAME, i, temp);
 			/*
 			 * If this core is already online, then bring up the
 			 * next offlined core.
@@ -1118,10 +1227,10 @@ static int __ref update_offline_cores(int val)
 	uint32_t cpu = 0;
 	int ret = 0;
 
-	if (!core_control_enabled)
-		return 0;
+	cpus_offlined = msm_thermal_info_local.core_control_mask & val;
 
-	cpus_offlined = msm_thermal_info.core_control_mask & val;
+	if (!core_control)
+		return 0;
 
 	for_each_possible_cpu(cpu) {
 		if (!(cpus_offlined & BIT(cpu)))
@@ -1142,12 +1251,14 @@ static __ref int do_hotplug(void *data)
 {
 	int ret = 0;
 	uint32_t cpu = 0, mask = 0;
+	struct sched_param param = {.sched_priority = MAX_RT_PRIO-2};
 
-	if (!core_control_enabled) {
+	if (!core_control) {
 		pr_debug("Core control disabled\n");
-		return -EINVAL;
+		return 0;
 	}
 
+	sched_setscheduler(current, SCHED_FIFO, &param);
 	while (!kthread_should_stop()) {
 		while (wait_for_completion_interruptible(
 			&hotplug_notify_complete) != 0)
@@ -1432,41 +1543,64 @@ static void do_freq_control(long temp)
 	uint32_t cpu = 0;
 	uint32_t max_freq = cpus[cpu].limited_max_freq;
 
-	if (temp >= msm_thermal_info.limit_temp_degC) {
+	if (safety == 1) {
+		if (msm_thermal_info.limit_temp_degC > 85)
+			msm_thermal_info.limit_temp_degC = 85;
+	}
+
+	if (debug_mode == 1)
+		printk(KERN_ERR "pre-check do_freq_control temp[%ld], \
+				limit_idx[%d], limit_idx_low[%d], \
+				limited_idx_high[%d]\n",
+				temp, limit_idx, limit_idx_low,
+				limit_idx_high);
+
+	if (temp >= msm_thermal_info_local.limit_temp_degC) {
 		if (limit_idx == limit_idx_low)
 			return;
 
-		limit_idx -= msm_thermal_info.bootup_freq_step;
+		limit_idx -= msm_thermal_info_local.freq_step;
 		if (limit_idx < limit_idx_low)
 			limit_idx = limit_idx_low;
-		max_freq = table[limit_idx].frequency;
-	} else if (temp < msm_thermal_info.limit_temp_degC -
-		 msm_thermal_info.temp_hysteresis_degC) {
+		/* Consider saved policy->max freq */
+		max_freq = table[min(max_idx -
+					(int)msm_thermal_info_local.freq_step,
+					limit_idx)].frequency;
+	} else if (temp < msm_thermal_info_local.limit_temp_degC -
+			msm_thermal_info_local.temp_hysteresis_degC) {
 		if (limit_idx == limit_idx_high)
 			return;
 
-		limit_idx += msm_thermal_info.bootup_freq_step;
-		if (limit_idx >= limit_idx_high) {
+		limit_idx += msm_thermal_info_local.freq_step;
+		limit_idx_high = min(max_idx, limit_idx_high);
+		if ((limit_idx >= limit_idx_high) ||
+			immediately_limit_stop == true) {
 			limit_idx = limit_idx_high;
-			max_freq = UINT_MAX;
+			max_freq = CORE_MAX_FREQ;
 		} else
 			max_freq = table[limit_idx].frequency;
 	}
 
+	if (debug_mode == 1)
+		printk(KERN_ERR "do_freq_control temp[%ld], \
+				limit_idx[%d], max_freq[%d], \
+				limited_max_freq[%d]\n",
+				temp, limit_idx, max_freq,
+				cpus[cpu].limited_max_freq);
+
 	if (max_freq == cpus[cpu].limited_max_freq)
 		return;
 
 	/* Update new limits */
-	get_online_cpus();
 	for_each_possible_cpu(cpu) {
-		if (!(msm_thermal_info.bootup_freq_control_mask & BIT(cpu)))
+		if (!(msm_thermal_info_local.freq_control_mask & BIT(cpu)))
 			continue;
-		pr_info("Limiting CPU%d max frequency to %u. Temp:%ld\n",
-			cpu, max_freq, temp);
 		cpus[cpu].limited_max_freq = max_freq;
-		update_cpu_freq(cpu);
+		if (cpu_online(cpu)) {
+			if (cpufreq_update_policy(cpu))
+				pr_info("Unable to update policy for cpu:%d\n", cpu);
+		}
 	}
-	put_online_cpus();
 }
 
 static void check_temp(struct work_struct *work)
@@ -1477,12 +1611,23 @@ static void check_temp(struct work_struct *work)
 
 	do_therm_reset();
 
-	ret = therm_get_temp(msm_thermal_info.sensor_id, THERM_TSENS_ID, &temp);
+	ret = therm_get_temp(msm_thermal_info_local.sensor_id, THERM_TSENS_ID, &temp);
 	if (ret) {
 		pr_err("Unable to read TSENS sensor:%d. err:%d\n",
-				msm_thermal_info.sensor_id, ret);
+				msm_thermal_info_local.sensor_id, ret);
 		goto reschedule;
 	}
+
+#ifdef CONFIG_INTELLI_THERMAL_STATS
+	if (hist_index < MAX_HISTORY_SZ)
+		msm_thermal_stats.temp_history[hist_index] = temp;
+	else {
+		hist_index = 0;
+		msm_thermal_stats.temp_history[hist_index] = temp;
+	}
+	hist_index++;
+#endif
+
 	do_core_control(temp);
 	do_psm();
 	do_gfx_phase_cond();
@@ -1500,9 +1645,9 @@ static void check_temp(struct work_struct *work)
 	do_freq_control(temp);
 
 reschedule:
-	if (polling_enabled)
-		schedule_delayed_work(&check_temp_work,
-				msecs_to_jiffies(msm_thermal_info.poll_ms));
+	if (intelli_enabled)
+		schedule_delayed_work(&check_temp_work, msecs_to_jiffies(
+					msm_thermal_info_local.poll_ms));
 }
 
 static int __ref msm_thermal_cpu_callback(struct notifier_block *nfb,
@@ -1511,17 +1656,21 @@ static int __ref msm_thermal_cpu_callback(struct notifier_block *nfb,
 	uint32_t cpu = (uint32_t)hcpu;
 
 	if (action == CPU_UP_PREPARE || action == CPU_UP_PREPARE_FROZEN) {
-		if (core_control_enabled &&
-			(msm_thermal_info.core_control_mask & BIT(cpu)) &&
-			(cpus_offlined & BIT(cpu))) {
-			pr_debug("Preventing CPU%d from coming online.\n",
-				cpu);
+		if (core_control && (
+				msm_thermal_info_local.core_control_mask &
+				BIT(cpu)) && (cpus_offlined & BIT(cpu))) {
+			if (debug_mode == 1)
+				pr_info("%s: Preventing cpu%d from coming \
+						online.\n", KBUILD_MODNAME,
+						cpu);
 			return NOTIFY_BAD;
 		}
 	}
 
-	pr_debug("voting for CPU%d to be online\n", cpu);
+	if (debug_mode == 1)
+		pr_debug("voting for CPU%d to be online\n", cpu);
 	return NOTIFY_OK;
+
 }
 
 static struct notifier_block __refdata msm_thermal_cpu_notifier = {
@@ -1533,7 +1682,7 @@ static int hotplug_notify(enum thermal_trip_type type, int temp, void *data)
 
 	pr_info_ratelimited("%s reach temp threshold: %d\n", cpu_node->sensor_type, temp);
 
-	if (!(msm_thermal_info.core_control_mask & BIT(cpu_node->cpu)))
+	if (!(msm_thermal_info_local.core_control_mask & BIT(cpu_node->cpu)))
 		return 0;
 	switch (type) {
 	case THERMAL_TRIP_CONFIGURABLE_HI:
@@ -1565,7 +1714,7 @@ static int hotplug_init_cpu_offlined(void)
 
 	mutex_lock(&core_control_mutex);
 	for_each_possible_cpu(cpu) {
-		if (!(msm_thermal_info.core_control_mask & BIT(cpus[cpu].cpu)))
+		if (!(msm_thermal_info_local.core_control_mask & BIT(cpus[cpu].cpu)))
 			continue;
 		if (therm_get_temp(cpus[cpu].sensor_id, cpus[cpu].id_type,
 					&temp)) {
@@ -1607,7 +1756,7 @@ static void hotplug_init(void)
 		cpus[cpu].sensor_id =
 			sensor_get_id((char *)cpus[cpu].sensor_type);
 		cpus[cpu].id_type = THERM_ZONE_ID;
-		if (!(msm_thermal_info.core_control_mask & BIT(cpus[cpu].cpu)))
+		if (!(msm_thermal_info_local.core_control_mask & BIT(cpus[cpu].cpu)))
 			continue;
 
 		hi_thresh = &cpus[cpu].threshold[HOTPLUG_THRESHOLD_HIGH];
@@ -1640,26 +1789,43 @@ static void hotplug_init(void)
 
 static __ref int do_freq_mitigation(void *data)
 {
+	long temp = 0;
 	int ret = 0;
+	bool skip_mitig = false;
 	uint32_t cpu = 0, max_freq_req = 0, min_freq_req = 0;
+	struct sched_param param = {.sched_priority = MAX_RT_PRIO-1};
 
+	sched_setscheduler(current, SCHED_FIFO, &param);
 	while (!kthread_should_stop()) {
 		while (wait_for_completion_interruptible(
 			&freq_mitigation_complete) != 0)
 			;
 		INIT_COMPLETION(freq_mitigation_complete);
 
+		ret = therm_get_temp(msm_thermal_info.sensor_id,
+			THERM_TSENS_ID, &temp);
+		if (ret)
+			pr_err("Unable to read TSENS sensor:%d\n",
+				msm_thermal_info.sensor_id);
+		else if (temp <= msm_thermal_info.limit_temp_degC)
+			skip_mitig = true;
+		else
+			skip_mitig = false;
+
 		get_online_cpus();
 		for_each_possible_cpu(cpu) {
 			max_freq_req = (cpus[cpu].max_freq) ?
 					msm_thermal_info.freq_limit :
-					UINT_MAX;
+					CORE_MAX_FREQ;
 			max_freq_req = min(max_freq_req,
 					cpus[cpu].user_max_freq);
 
 			min_freq_req = max(min_freq_limit,
 					cpus[cpu].user_min_freq);
 
+				if (skip_mitig && CORE_MAX_FREQ > max_freq_req)
+				max_freq_req = CORE_MAX_FREQ;
+
 			if ((max_freq_req == cpus[cpu].limited_max_freq)
 				&& (min_freq_req ==
 				cpus[cpu].limited_min_freq))
@@ -2303,13 +2469,16 @@ static void __ref disable_msm_thermal(void)
 
 	get_online_cpus();
 	for_each_possible_cpu(cpu) {
-		if (cpus[cpu].limited_max_freq == UINT_MAX &&
+		if (cpus[cpu].limited_max_freq == CORE_MAX_FREQ &&
 			cpus[cpu].limited_min_freq == 0)
 			continue;
 		pr_info("Max frequency reset for CPU%d\n", cpu);
-		cpus[cpu].limited_max_freq = UINT_MAX;
+		cpus[cpu].limited_max_freq = CORE_MAX_FREQ;
 		cpus[cpu].limited_min_freq = 0;
-		update_cpu_freq(cpu);
+		if (cpu_online(cpu)) {
+			if (cpufreq_update_policy(cpu))
+				pr_info("Unable to update policy for cpu:%d\n", cpu);
+		}
 	}
 	put_online_cpus();
 }
@@ -2320,9 +2489,9 @@ static void interrupt_mode_init(void)
 		interrupt_mode_enable = true;
 		return;
 	}
-	if (polling_enabled) {
+	if (intelli_enabled) {
 		pr_info("Interrupt mode init\n");
-		polling_enabled = 0;
+		intelli_enabled = 0;
 		disable_msm_thermal();
 		hotplug_init();
 		freq_mitigation_init();
@@ -2336,30 +2505,139 @@ static int __ref set_enabled(const char *val, const struct kernel_param *kp)
 {
 	int ret = 0;
 
-	ret = param_set_bool(val, kp);
-	if (!enabled)
+	if (*val == '0' || *val == 'n' || *val == 'N') {
 		interrupt_mode_init();
-	else
-		pr_info("no action for enabled = %d\n",
-			enabled);
-
-	pr_info("enabled = %d\n", enabled);
+		pr_info("%s: disabled!\n", KBUILD_MODNAME);
+	} else {
+		if (!intelli_enabled) {
+			intelli_enabled = 1;
+			schedule_delayed_work(&check_temp_work,
+					msecs_to_jiffies(1000));
+			pr_info("%s: rescheduling...\n", KBUILD_MODNAME);
+		} else
+			pr_info("%s: already running...\n \
+				if you wish to disable echo N > \
+				intelli_enabled\n", KBUILD_MODNAME);
+	}
+	ret = param_set_bool(val, kp);
+	pr_info("%s: intelli_enabled = %d\n", KBUILD_MODNAME, intelli_enabled);
 
 	return ret;
 }
-
 static struct kernel_param_ops module_ops = {
 	.set = set_enabled,
 	.get = param_get_bool,
 };
 
-module_param_cb(enabled, &module_ops, &enabled, 0644);
-MODULE_PARM_DESC(enabled, "enforce thermal limit on cpu");
+module_param_cb(intelli_enabled, &module_ops, &intelli_enabled, 0644);
+MODULE_PARM_DESC(intelli_enabled, "enforce thermal limit on cpu");
+
+#ifdef CONFIG_INTELLI_THERMAL_STATS
+static ssize_t show_thermal_stats(struct kobject *kobj,
+                struct kobj_attribute *attr, char *buf)
+{
+
+	int i = 0;
+	int tmp = 0;
+
+	/* clear out old stats */
+	msm_thermal_stats.throttled = 0;
+	msm_thermal_stats.warning = 0;
+	msm_thermal_stats.normal = 0;
+
+	for (i = 0; i < MAX_HISTORY_SZ; i++) {
+		tmp = msm_thermal_stats.temp_history[i];
+		if (tmp >= msm_thermal_info_local.limit_temp_degC)
+			msm_thermal_stats.throttled++;
+		else if (tmp < msm_thermal_info_local.limit_temp_degC &&
+			 tmp >= (msm_thermal_info_local.limit_temp_degC -
+				 msm_thermal_info_local.temp_hysteresis_degC))
+			msm_thermal_stats.warning++;
+		else
+			msm_thermal_stats.normal++;
+	}
+        return snprintf(buf, PAGE_SIZE, "%u %u %u\n",
+			msm_thermal_stats.throttled,
+			msm_thermal_stats.warning,
+			msm_thermal_stats.normal);
+}
+static __refdata struct kobj_attribute msm_thermal_stat_attr =
+__ATTR(statistics, 0444, show_thermal_stats, NULL);
+
+static __refdata struct attribute *msm_thermal_stat_attrs[] = {
+        &msm_thermal_stat_attr.attr,
+        NULL,
+};
+
+static __refdata struct attribute_group msm_thermal_stat_attr_group = {
+        .attrs = msm_thermal_stat_attrs,
+};
+
+static __init int msm_thermal_add_stat_nodes(void)
+{
+	struct kobject *module_kobj = NULL;
+	struct kobject *stat_kobj = NULL;
+	int ret = 0;
+
+	module_kobj = kset_find_obj(module_kset, KBUILD_MODNAME);
+	if (!module_kobj) {
+		pr_err("%s: cannot find kobject for module\n",
+			KBUILD_MODNAME);
+		ret = -ENOENT;
+		goto done_stat_nodes;
+	}
+
+	stat_kobj = kobject_create_and_add("thermal_stats", module_kobj);
+	if (!stat_kobj) {
+		pr_err("%s: cannot create core control kobj\n",
+				KBUILD_MODNAME);
+		ret = -ENOMEM;
+		goto done_stat_nodes;
+	}
+
+	ret = sysfs_create_group(stat_kobj, &msm_thermal_stat_attr_group);
+	if (ret) {
+		pr_err("%s: cannot create group\n", KBUILD_MODNAME);
+		goto done_stat_nodes;
+	}
+
+	return 0;
+
+done_stat_nodes:
+	if (stat_kobj)
+		kobject_del(stat_kobj);
+	return ret;
+}
+#endif
+
+static ssize_t show_cc_enabled_dummy(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", enabled);
+}
+
+static ssize_t __ref store_cc_enabled_dummy(struct kobject *kobj,
+                struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int ret = 0;
+	int val = 0;
+
+	ret = kstrtoint(buf, 10, &val);
+	if (ret)
+		pr_err("%s: Invalid input %s\n", KBUILD_MODNAME, buf);
+
+	if (enabled == val)
+		return count;
+
+	enabled = val;
+
+	return count;
+}
 
 static ssize_t show_cc_enabled(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, "%d\n", core_control_enabled);
+	return snprintf(buf, PAGE_SIZE, "%d\n", core_control);
 }
 
 static ssize_t __ref store_cc_enabled(struct kobject *kobj,
@@ -2374,13 +2652,14 @@ static ssize_t __ref store_cc_enabled(struct kobject *kobj,
 		goto done_store_cc;
 	}
 
-	if (core_control_enabled == !!val)
+	if (core_control == !!val)
 		goto done_store_cc;
 
-	core_control_enabled = !!val;
-	if (core_control_enabled) {
+	core_control = !!val;
+	if (core_control) {
 		pr_info("Core control enabled\n");
 		register_cpu_notifier(&msm_thermal_cpu_notifier);
+		enabled = 1;
 		if (hotplug_task)
 			complete(&hotplug_notify_complete);
 		else
@@ -2388,6 +2667,7 @@ static ssize_t __ref store_cc_enabled(struct kobject *kobj,
 	} else {
 		pr_info("Core control disabled\n");
 		unregister_cpu_notifier(&msm_thermal_cpu_notifier);
+		enabled = 0;
 	}
 
 done_store_cc:
@@ -2414,13 +2694,13 @@ static ssize_t __ref store_cpus_offlined(struct kobject *kobj,
 		goto done_cc;
 	}
 
-	if (polling_enabled) {
+	if (intelli_enabled) {
 		pr_err("Ignoring request; polling thread is enabled.\n");
 		goto done_cc;
 	}
 
 	for_each_possible_cpu(cpu) {
-		if (!(msm_thermal_info.core_control_mask & BIT(cpu)))
+		if (!(msm_thermal_info_local.core_control_mask & BIT(cpu)))
 			continue;
 		cpus[cpu].user_offline = !!(val & BIT(cpu));
 		pr_debug("\"%s\"(PID:%i) requests %s CPU%d.\n", current->comm,
@@ -2438,13 +2718,17 @@ static ssize_t __ref store_cpus_offlined(struct kobject *kobj,
 }
 
 static __refdata struct kobj_attribute cc_enabled_attr =
-__ATTR(enabled, 0644, show_cc_enabled, store_cc_enabled);
+__ATTR(core_control, 0664, show_cc_enabled, store_cc_enabled);
+
+static __refdata struct kobj_attribute cc_enabled_dummy_attr =
+__ATTR(enabled, 0664, show_cc_enabled_dummy, store_cc_enabled_dummy);
 
 static __refdata struct kobj_attribute cpus_offlined_attr =
-__ATTR(cpus_offlined, 0644, show_cpus_offlined, store_cpus_offlined);
+__ATTR(cpus_offlined, 0664, show_cpus_offlined, store_cpus_offlined);
 
 static __refdata struct attribute *cc_attrs[] = {
 	&cc_enabled_attr.attr,
+	&cc_enabled_dummy_attr.attr,
 	&cpus_offlined_attr.attr,
 	NULL,
 };
@@ -2555,30 +2839,35 @@ int msm_thermal_init(struct msm_thermal_data *pdata)
 		cpus[cpu].user_offline = 0;
 		cpus[cpu].hotplug_thresh_clear = false;
 		cpus[cpu].max_freq = false;
-		cpus[cpu].user_max_freq = UINT_MAX;
+		cpus[cpu].user_max_freq = CORE_MAX_FREQ;
 		cpus[cpu].user_min_freq = 0;
-		cpus[cpu].limited_max_freq = UINT_MAX;
+		cpus[cpu].limited_max_freq = CORE_MAX_FREQ;
 		cpus[cpu].limited_min_freq = 0;
 		cpus[cpu].freq_thresh_clear = false;
 	}
 	BUG_ON(!pdata);
 	memcpy(&msm_thermal_info, pdata, sizeof(struct msm_thermal_data));
 
-	if (check_sensor_id(msm_thermal_info.sensor_id)) {
+	if (check_sensor_id(msm_thermal_info_local.sensor_id)) {
 		pr_err("Invalid sensor:%d for polling\n",
-				msm_thermal_info.sensor_id);
+				msm_thermal_info_local.sensor_id);
 		return -EINVAL;
 	}
 
+	pr_info("%s: polling enabled!\n", KBUILD_MODNAME);
+
+	if (num_possible_cpus() > 1)
+		core_control = 1;
 	enabled = 1;
-	polling_enabled = 1;
+	intelli_enabled = 1;
 	ret = cpufreq_register_notifier(&msm_thermal_cpufreq_notifier,
 			CPUFREQ_POLICY_NOTIFIER);
 	if (ret)
 		pr_err("cannot register cpufreq notifier. err:%d\n", ret);
 
 	INIT_DELAYED_WORK(&check_temp_work, check_temp);
-	schedule_delayed_work(&check_temp_work, 0);
+	schedule_delayed_work(&check_temp_work,
+			msecs_to_jiffies(5000));
 
 	if (num_possible_cpus() > 1)
 		register_cpu_notifier(&msm_thermal_cpu_notifier);
@@ -3008,25 +3297,10 @@ static int probe_cc(struct device_node *node, struct msm_thermal_data *data,
 	uint32_t cpu = 0;
 
 	if (num_possible_cpus() > 1) {
-		core_control_enabled = 1;
+		core_control = 1;
 		hotplug_enabled = 1;
 	}
 
-	key = "qcom,core-limit-temp";
-	ret = of_property_read_u32(node, key, &data->core_limit_temp_degC);
-	if (ret)
-		goto read_node_fail;
-
-	key = "qcom,core-temp-hysteresis";
-	ret = of_property_read_u32(node, key, &data->core_temp_hysteresis_degC);
-	if (ret)
-		goto read_node_fail;
-
-	key = "qcom,core-control-mask";
-	ret = of_property_read_u32(node, key, &data->core_control_mask);
-	if (ret)
-		goto read_node_fail;
-
 	key = "qcom,hotplug-temp";
 	ret = of_property_read_u32(node, key, &data->hotplug_temp_degC);
 	if (ret)
@@ -3053,16 +3327,6 @@ static int probe_cc(struct device_node *node, struct msm_thermal_data *data,
 			goto hotplug_node_fail;
 	}
 
-read_node_fail:
-	if (ret) {
-		dev_info(&pdev->dev,
-		"%s:Failed reading node=%s, key=%s. err=%d. KTM continues\n",
-			KBUILD_MODNAME, node->full_name, key, ret);
-		core_control_enabled = 0;
-	}
-
-	return ret;
-
 hotplug_node_fail:
 	if (ret) {
 		dev_info(&pdev->dev,
@@ -3301,6 +3565,8 @@ static int msm_thermal_dev_probe(struct platform_device *pdev)
 	struct device_node *node = pdev->dev.of_node;
 	struct msm_thermal_data data;
 
+	pr_info("%s: msm_thermal_dev_probe begin...\n", KBUILD_MODNAME);
+
 	memset(&data, 0, sizeof(struct msm_thermal_data));
 	ret = msm_thermal_pre_init(&pdev->dev);
 	if (ret) {
@@ -3308,34 +3574,6 @@ static int msm_thermal_dev_probe(struct platform_device *pdev)
 		goto fail;
 	}
 
-	key = "qcom,sensor-id";
-	ret = of_property_read_u32(node, key, &data.sensor_id);
-	if (ret)
-		goto fail;
-
-	key = "qcom,poll-ms";
-	ret = of_property_read_u32(node, key, &data.poll_ms);
-	if (ret)
-		goto fail;
-
-	key = "qcom,limit-temp";
-	ret = of_property_read_u32(node, key, &data.limit_temp_degC);
-	if (ret)
-		goto fail;
-
-	key = "qcom,temp-hysteresis";
-	ret = of_property_read_u32(node, key, &data.temp_hysteresis_degC);
-	if (ret)
-		goto fail;
-
-	key = "qcom,freq-step";
-	ret = of_property_read_u32(node, key, &data.bootup_freq_step);
-	if (ret)
-		goto fail;
-
-	key = "qcom,freq-control-mask";
-	ret = of_property_read_u32(node, key, &data.bootup_freq_control_mask);
-
 	ret = probe_cc(node, &data, pdev);
 
 	ret = probe_freq_mitigation(node, &data, pdev);
@@ -3375,12 +3613,16 @@ static int msm_thermal_dev_probe(struct platform_device *pdev)
 		interrupt_mode_enable = false;
 	}
 
+	pr_info("%s: msm_thermal_dev_probe completed!\n", KBUILD_MODNAME);
+
 	return ret;
 fail:
 	if (ret)
 		pr_err("Failed reading node=%s, key=%s. err:%d\n",
 			node->full_name, key, ret);
 
+	pr_info("%s: msm_thermal_dev_probe failed!\n", KBUILD_MODNAME);
+
 	return ret;
 }
 
@@ -3401,6 +3643,7 @@ static int msm_thermal_dev_exit(struct platform_device *inp_dev)
 		kfree(thresh);
 		thresh = NULL;
 	}
+	pr_info("msm_thermal_dev: removed!\n");
 	return 0;
 }
 
@@ -3430,8 +3673,13 @@ int __init msm_thermal_late_init(void)
 	if (num_possible_cpus() > 1)
 		msm_thermal_add_cc_nodes();
 	msm_thermal_add_psm_nodes();
-	msm_thermal_add_vdd_rstr_nodes();
 	interrupt_mode_init();
+	msm_thermal_add_vdd_rstr_nodes();
+
+#ifdef CONFIG_INTELLI_THERMAL_STATS
+	msm_thermal_add_stat_nodes();
+#endif
+
 	return 0;
 }
 late_initcall(msm_thermal_late_init);
diff --git a/include/linux/msm_thermal.h b/include/linux/msm_thermal.h
index 294bd20..ae78c22 100644
--- a/include/linux/msm_thermal.h
+++ b/include/linux/msm_thermal.h
@@ -48,6 +48,18 @@ struct msm_thermal_data {
 	int32_t therm_reset_temp_degC;
 };
 
+struct msm_thermal_data_intelli {
+	uint32_t sensor_id;
+	uint32_t poll_ms;
+	int32_t limit_temp_degC;
+	int32_t temp_hysteresis_degC;
+	uint32_t freq_step;
+	uint32_t freq_control_mask;
+	int32_t core_limit_temp_degC;
+	int32_t core_temp_hysteresis_degC;
+	uint32_t core_control_mask;
+};
+
 #if defined (CONFIG_THERMAL_MONITOR) || defined (CONFIG_INTELLI_THERMAL)
 extern int msm_thermal_init(struct msm_thermal_data *pdata);
 extern int msm_thermal_device_init(void);
