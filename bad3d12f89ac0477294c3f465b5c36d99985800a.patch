From bad3d12f89ac0477294c3f465b5c36d99985800a Mon Sep 17 00:00:00 2001
From: ion-storm <defconoii@gmail.com>
Date: Mon, 14 Jul 2014 00:17:57 -0400
Subject: [PATCH] mm: remove compressed copy from zram in-memory

Swap subsystem does lazy swap slot free with expecting the page would be
swapped out again so we can avoid unnecessary write.

But the problem in in-memory swap(ex, zram) is that it consumes memory
space until vm_swap_full(ie, used half of all of swap device) condition
meet.  It could be bad if we use multiple swap device, small in-memory
swap and big storage swap or in-memory swap alone.

This patch makes swap subsystem free swap slot as soon as swap-read is
completed and make the swapcache page dirty so the page should be
written out the swap device to reclaim it.  It means we never lose it.

I tested this patch with kernel compile workload.

1. before

   compile time : 9882.42
   zram max wasted space by fragmentation: 13471881 byte
   memory space consumed by zram: 174227456 byte
   the number of slot free notify: 206684

2. after

   compile time : 9653.90
   zram max wasted space by fragmentation: 11805932 byte
   memory space consumed by zram: 154001408 byte
   the number of slot free notify: 426972

Change-Id: Ida7dcf6fbd67408e2429483c28c75f59f83310d3
[akpm@linux-foundation.org: tweak comment text]
[artem.savkov@gmail.com: fix BUG due to non-swapcache pages in end_swap_bio_read()]
[akpm@linux-foundation.org: invert unlikely() test, augment comment, 80-col cleanup]
Signed-off-by: Dan Magenheimer <dan.magenheimer@oracle.com>
Signed-off-by: Minchan Kim <minchan@kernel.org>
Signed-off-by: Artem Savkov <artem.savkov@gmail.com>
Cc: Hugh Dickins <hughd@google.com>
Cc: Seth Jennings <sjenning@linux.vnet.ibm.com>
Cc: Nitin Gupta <ngupta@vflare.org>
Cc: Konrad Rzeszutek Wilk <konrad@darnok.org>
Cc: Shaohua Li <shli@kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Git-commit: b430e9d1c6d416306d44dbf3aa3148be7af78abc
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
[ohaugan@codeaurora.org: Resolved merge issues]
Signed-off-by: Olav Haugan <ohaugan@codeaurora.org>
mm: vmscan: Move pages that fail swapout to LRU active list

Move pages that fail swapout to the LRU active list to reduce
pressure on swap device when swapping out is already failing.
This helps when using a pseudo swap device such as zram which
starts failing when memory is low.

Change-Id: Ib136cd0a744378aa93d837a24b9143ee818c80b3
Signed-off-by: Olav Haugan <ohaugan@codeaurora.org>
msm: display: mipi_lgit: Userspace display gamma control

Originally written by Paul Reioux (faux123)

Modified from his original implementation as follows:
* Remove kgamma_ctrl sysfs entry - it did absolutely nothing
* Alter the show() functions to output the checksum in the
first entry, in order to match the expected input of
the store() functions.  This should not break existing
applications
* Move store/show code to a common function
* Add limit checks from Mike Cain (motley)
* Added a kgamma_apply sysfs entry which will apply
  the current state when anything is stored to it,
  instead of waiting until the next time the LCD
  is power cycled

Change-Id: I8835e42709cefa547e02e28a7e5a381d88282700
---
 drivers/video/msm/mipi_lgit.c | 187 +++++++++++++++++++++++++++++++++++++++++-
 mm/page_io.c                  |  51 +++++++++++-
 mm/vmscan.c                   |   2 +
 3 files changed, 235 insertions(+), 5 deletions(-)

diff --git a/drivers/video/msm/mipi_lgit.c b/drivers/video/msm/mipi_lgit.c
index 4901f7d..bdeac7d 100644
--- a/drivers/video/msm/mipi_lgit.c
+++ b/drivers/video/msm/mipi_lgit.c
@@ -1,6 +1,7 @@
 /*
- *  Copyright (C) 2011-2012, LG Eletronics,Inc. All rights reserved.
- *      LGIT LCD device driver
+ * Copyright (C) 2013 The CyanogenMod Project
+ * Copyright (C) 2011-2012, LG Eletronics,Inc. All rights reserved.
+ *     LGIT LCD device driver
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -17,6 +18,7 @@
  * 02110-1301, USA.
  *
  */
+#include <linux/string.h>
 #include <linux/gpio.h>
 #include <linux/syscore_ops.h>
 
@@ -27,10 +29,17 @@
 
 static struct msm_panel_common_pdata *mipi_lgit_pdata;
 
+#ifdef CONFIG_LGIT_VIDEO_WXGA_CABC
+struct dsi_cmd_desc local_power_on_set_1[33];
+#else
+struct dsi_cmd_desc local_power_on_set_1[28];
+#endif
+
 static struct dsi_buf lgit_tx_buf;
 static struct dsi_buf lgit_rx_buf;
 static struct msm_fb_data_type *local_mfd;
 static int skip_init;
+static int lcd_isactive = 0;
 
 #define DSV_ONBST 57
 
@@ -77,9 +86,10 @@ static int mipi_lgit_lcd_on(struct platform_device *pdev)
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
+	lcd_isactive = 1;
 	MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x10000000);
 	ret = mipi_dsi_cmds_tx(&lgit_tx_buf,
-			mipi_lgit_pdata->power_on_set_1,
+			local_power_on_set_1,
 			mipi_lgit_pdata->power_on_set_size_1);
 	MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x14000000);
 	if (ret < 0) {
@@ -138,6 +148,8 @@ static int mipi_lgit_lcd_off(struct platform_device *pdev)
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
+	lcd_isactive = 0;
+
 	MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x10000000);
 	ret = mipi_dsi_cmds_tx(&lgit_tx_buf,
 			mipi_lgit_pdata->power_off_set_1,
@@ -221,13 +233,166 @@ struct syscore_ops panel_syscore_ops = {
 	.shutdown = mipi_lgit_lcd_shutdown,
 };
 
+/******************* Begin sysfs interface *******************/
+
+static unsigned char calc_checksum(int intArr[]) {
+	int i = 0;
+	unsigned char chksum = 0;
+
+	for (i=1; i<10; i++)
+		chksum += intArr[i];
+
+	return chksum;
+}
+
+static ssize_t do_kgamma_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count,
+				unsigned int offset)
+{
+	int kgamma[10];
+	int i;
+
+	sscanf(buf, "%d %d %d %d %d %d %d %d %d %d",
+		&kgamma[0], &kgamma[1], &kgamma[2], &kgamma[3],
+		&kgamma[4], &kgamma[5], &kgamma[6], &kgamma[7],
+		&kgamma[8], &kgamma[9]);
+
+	if (kgamma[5] > 31 || (kgamma[6] > 31)) {
+		pr_info("gamma 0 and gamma 1 values can't be over 31, got %d %d instead!", kgamma[5], kgamma[6]);
+		return -EINVAL;
+	}
+
+	for (i=1; i<10; i++) {
+		if (kgamma[i] > 255) {
+			pr_info("char values  can't be over 255, got %d instead!", kgamma[i]);
+			return -EINVAL;
+		}
+	}
+
+	if (calc_checksum(kgamma) == (unsigned char) kgamma[0]) {
+		kgamma[0] = 0xd0 + offset;
+		for (i=0; i<10; i++) {
+			pr_info("kgamma_p [%d] => %d \n", i, kgamma[i]);
+			local_power_on_set_1[5+offset].payload[i] = kgamma[i];
+		}
+
+		kgamma[0] = 0xd1 + offset;
+		for (i=0; i<10; i++) {
+			pr_info("kgamma_n [%d] => %d \n", i, kgamma[i]);
+			local_power_on_set_1[6+offset].payload[i] = kgamma[i];
+		}
+		return count;
+	}
+	return -EINVAL;
+}
+
+static ssize_t do_kgamma_show(struct device *dev, struct device_attribute *attr,
+				char *buf, unsigned int offset)
+{
+	int kgamma[10];
+	int i;
+
+	for (i=1; i<10; i++)
+		kgamma[i] = local_power_on_set_1[5+offset].payload[i];
+
+	kgamma[0] = (int) calc_checksum(kgamma);
+
+	return sprintf(buf, "%d %d %d %d %d %d %d %d %d %d",
+		kgamma[0], kgamma[1], kgamma[2], kgamma[3],
+		kgamma[4], kgamma[5], kgamma[6], kgamma[7],
+		kgamma[8], kgamma[9]);
+}
+
+static ssize_t kgamma_r_store(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	return do_kgamma_store(dev,attr,buf,count,0);
+}
+
+static ssize_t kgamma_r_show(struct device *dev, struct device_attribute *attr,
+								char *buf)
+{
+	return do_kgamma_show(dev,attr,buf,0);
+}
+
+static ssize_t kgamma_g_store(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	return do_kgamma_store(dev,attr,buf,count,2);
+}
+
+static ssize_t kgamma_g_show(struct device *dev, struct device_attribute *attr,
+								char *buf)
+{
+	return do_kgamma_show(dev,attr,buf,2);
+}
+
+static ssize_t kgamma_b_store(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	return do_kgamma_store(dev,attr,buf,count,4);
+}
+
+static ssize_t kgamma_b_show(struct device *dev, struct device_attribute *attr,
+								char *buf)
+{
+	return do_kgamma_show(dev,attr,buf,4);
+}
+
+static ssize_t kgamma_apply_store(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	int ret = 0;
+
+	/*
+	 * Only attempt to apply if the LCD is active.
+	 * If it isn't, the device will panic-reboot
+	 */
+	if(lcd_isactive) {
+		MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x10000000);
+		ret = mipi_dsi_cmds_tx(&lgit_tx_buf,
+				local_power_on_set_1,
+				mipi_lgit_pdata->power_on_set_size_1);
+		MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x14000000);
+		if (ret < 0) {
+			pr_err("%s: failed to transmit power_on_set_1 cmds\n", __func__);
+			return ret;
+		}
+	}
+	else {
+		pr_err("%s: Tried to apply gamma settings when LCD was off\n",__func__);
+		//Is ENODEV correct here?  Perhaps it should be something else?
+		return -ENODEV;
+	}
+	return count;
+}
+
+static ssize_t kgamma_apply_show(struct device *dev, struct device_attribute *attr,
+								char *buf)
+{
+	return 0;
+}
+
+static DEVICE_ATTR(kgamma_r, 0644, kgamma_r_show, kgamma_r_store);
+static DEVICE_ATTR(kgamma_g, 0644, kgamma_g_show, kgamma_g_store);
+static DEVICE_ATTR(kgamma_b, 0644, kgamma_b_show, kgamma_b_store);
+static DEVICE_ATTR(kgamma_apply, 0644, kgamma_apply_show, kgamma_apply_store);
+
+/******************* End sysfs interface *******************/
+
 static int mipi_lgit_lcd_probe(struct platform_device *pdev)
 {
+	int rc;
+
 	if (pdev->id == 0) {
 		mipi_lgit_pdata = pdev->dev.platform_data;
 		return 0;
 	}
 
+	// Make a copy of platform data
+	memcpy((void*)local_power_on_set_1, (void*)mipi_lgit_pdata->power_on_set_1,
+		sizeof(local_power_on_set_1));
+
 	pr_info("%s start\n", __func__);
 
 	skip_init = true;
@@ -235,6 +400,22 @@ static int mipi_lgit_lcd_probe(struct platform_device *pdev)
 
 	register_syscore_ops(&panel_syscore_ops);
 
+	rc = device_create_file(&pdev->dev, &dev_attr_kgamma_r);
+	if(rc !=0)
+		return -1;
+
+	rc = device_create_file(&pdev->dev, &dev_attr_kgamma_g);
+	if(rc !=0)
+		return -1;
+
+	rc = device_create_file(&pdev->dev, &dev_attr_kgamma_b);
+	if(rc !=0)
+		return -1;
+
+	rc = device_create_file(&pdev->dev, &dev_attr_kgamma_apply);
+	if(rc !=0)
+		return -1;
+
 	return 0;
 }
 
diff --git a/mm/page_io.c b/mm/page_io.c
index dc76b4d..e60e43f 100644
--- a/mm/page_io.c
+++ b/mm/page_io.c
@@ -1,3 +1,4 @@
+
 /*
  *  linux/mm/page_io.c
  *
@@ -18,6 +19,7 @@
 #include <linux/bio.h>
 #include <linux/swapops.h>
 #include <linux/writeback.h>
+#include <linux/blkdev.h>
 #include <asm/pgtable.h>
 
 static struct bio *get_swap_bio(gfp_t gfp_flags,
@@ -78,9 +80,54 @@ void end_swap_bio_read(struct bio *bio, int err)
 				imajor(bio->bi_bdev->bd_inode),
 				iminor(bio->bi_bdev->bd_inode),
 				(unsigned long long)bio->bi_sector);
-	} else {
-		SetPageUptodate(page);
+		goto out;
+	}
+
+	SetPageUptodate(page);
+
+	/*
+	 * There is no guarantee that the page is in swap cache - the software
+	 * suspend code (at least) uses end_swap_bio_read() against a non-
+	 * swapcache page.  So we must check PG_swapcache before proceeding with
+	 * this optimization.
+	 */
+	if (likely(PageSwapCache(page))) {
+		struct swap_info_struct *sis;
+
+		sis = page_swap_info(page);
+		if (sis->flags & SWP_BLKDEV) {
+			/*
+			 * The swap subsystem performs lazy swap slot freeing,
+			 * expecting that the page will be swapped out again.
+			 * So we can avoid an unnecessary write if the page
+			 * isn't redirtied.
+			 * This is good for real swap storage because we can
+			 * reduce unnecessary I/O and enhance wear-leveling
+			 * if an SSD is used as the as swap device.
+			 * But if in-memory swap device (eg zram) is used,
+			 * this causes a duplicated copy between uncompressed
+			 * data in VM-owned memory and compressed data in
+			 * zram-owned memory.  So let's free zram-owned memory
+			 * and make the VM-owned decompressed page *dirty*,
+			 * so the page should be swapped out somewhere again if
+			 * we again wish to reclaim it.
+			 */
+			struct gendisk *disk = sis->bdev->bd_disk;
+			if (disk->fops->swap_slot_free_notify) {
+				swp_entry_t entry;
+				unsigned long offset;
+
+				entry.val = page_private(page);
+				offset = swp_offset(entry);
+
+				SetPageDirty(page);
+				disk->fops->swap_slot_free_notify(sis->bdev,
+						offset);
+			}
+		}
 	}
+
+out:
 	unlock_page(page);
 	bio_put(bio);
 }
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 33dc256..49433ba 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -522,6 +522,8 @@ static pageout_t pageout(struct page *page, struct address_space *mapping,
 		if (!PageWriteback(page)) {
 			/* synchronous write or broken a_ops? */
 			ClearPageReclaim(page);
+			if (PageError(page))
+				return PAGE_ACTIVATE;
 		}
 		trace_mm_vmscan_writepage(page,
 			trace_reclaim_flags(page, sc->reclaim_mode));
