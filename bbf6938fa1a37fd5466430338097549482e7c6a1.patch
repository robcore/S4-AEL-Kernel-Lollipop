From bbf6938fa1a37fd5466430338097549482e7c6a1 Mon Sep 17 00:00:00 2001
From: Praveen Chidambaram <pchidamb@codeaurora.org>
Date: Fri, 3 May 2013 12:52:42 -0600
Subject: [PATCH] msm: thermal: Add cpu mask control for frequency limiting

Limit the number of cpus affected by kernel thermal module's frequency
control mechanism by specifying the participating cpus in the
freq-control-mask. Frequency control can be disabled, if the mask is 0.

Change-Id: Iab659730dd06ce59521917c8ba6210d7dd1311b0
Signed-off-by: Praveen Chidambaram <pchidamb@codeaurora.org>
---
 .../devicetree/bindings/arm/msm/msm_thermal.txt    |  3 +
 arch/arm/boot/dts/msm8226.dtsi                     |  1 +
 arch/arm/boot/dts/msm8610.dtsi                     |  1 +
 arch/arm/boot/dts/msm8974.dtsi                     |  1 +
 drivers/thermal/msm_thermal.c                      | 79 ++++++++++++++--------
 include/linux/msm_thermal.h                        |  1 +
 6 files changed, 57 insertions(+), 29 deletions(-)

diff --git a/Documentation/devicetree/bindings/arm/msm/msm_thermal.txt b/Documentation/devicetree/bindings/arm/msm/msm_thermal.txt
index 23498e5..6ef2b77 100644
--- a/Documentation/devicetree/bindings/arm/msm/msm_thermal.txt
+++ b/Documentation/devicetree/bindings/arm/msm/msm_thermal.txt
@@ -24,6 +24,8 @@ Required properties
 
 Optional properties
 
+- qcom,freq-control-mask: The cpu mask that will be used to determine if a
+			core can be used for freq control.
 - qcom,core-limit-temp: Threshold temperature to start shutting down cores
 			in degC
 - qcom,core-temp-hysterisis: Degrees C below which the cores will be brought
@@ -77,6 +79,7 @@ Example:
 		qcom,limit-temp = <60>;
 		qcom,temp-hysteresis = <10>;
 		qcom,freq-step = <2>;
+		qcom,freq-control-mask = <0xf>
 		qcom,core-limit-temp = <90>;
 		qcom,core-temp-hysterisis = <10>;
 		qcom,core-control-mask = <7>;
diff --git a/arch/arm/boot/dts/msm8226.dtsi b/arch/arm/boot/dts/msm8226.dtsi
index 9d77312..17cda51 100644
--- a/arch/arm/boot/dts/msm8226.dtsi
+++ b/arch/arm/boot/dts/msm8226.dtsi
@@ -869,6 +869,7 @@
 		qcom,limit-temp = <60>;
 		qcom,temp-hysteresis = <10>;
 		qcom,freq-step = <2>;
+		qcom,freq-control-mask = <0xf>;
 	};
 
 	spi_0: spi@f9923000 { /* BLSP1 QUP1 */
diff --git a/arch/arm/boot/dts/msm8610.dtsi b/arch/arm/boot/dts/msm8610.dtsi
index 9dbd71d..6347902 100644
--- a/arch/arm/boot/dts/msm8610.dtsi
+++ b/arch/arm/boot/dts/msm8610.dtsi
@@ -736,6 +736,7 @@
 		qcom,limit-temp = <60>;
 		qcom,temp-hysteresis = <10>;
 		qcom,freq-step = <2>;
+		qcom,freq-control-mask = <0xf>;
 	};
 
 	qcom,ipc-spinlock@fd484000 {
diff --git a/arch/arm/boot/dts/msm8974.dtsi b/arch/arm/boot/dts/msm8974.dtsi
index a4a3efe..e2dd3fd 100644
--- a/arch/arm/boot/dts/msm8974.dtsi
+++ b/arch/arm/boot/dts/msm8974.dtsi
@@ -1419,6 +1419,7 @@
 		qcom,limit-temp = <60>;
 		qcom,temp-hysteresis = <10>;
 		qcom,freq-step = <2>;
+		qcom,freq-control-mask = <0xf>;
 		qcom,core-limit-temp = <80>;
 		qcom,core-temp-hysteresis = <10>;
 		qcom,core-control-mask = <0xe>;
diff --git a/drivers/thermal/msm_thermal.c b/drivers/thermal/msm_thermal.c
index 814817b..ab59864 100644
--- a/drivers/thermal/msm_thermal.c
+++ b/drivers/thermal/msm_thermal.c
@@ -596,7 +596,14 @@ static int update_cpu_max_freq(int cpu, uint32_t max_freq)
 		pr_info("%s: Max frequency reset for cpu%d\n",
 				KBUILD_MODNAME, cpu);
 
-	ret = cpufreq_update_policy(cpu);
+	if (cpu_online(cpu)) {
+		struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+		if (!policy)
+			return ret;
+		ret = cpufreq_driver_target(policy, policy->cur,
+				CPUFREQ_RELATION_H);
+		cpufreq_cpu_put(policy);
+	}
 
 	return ret;
 }
@@ -748,37 +755,15 @@ static int do_psm(void)
 	return ret;
 }
 
-static void __cpuinit check_temp(struct work_struct *work)
+static void __cpuinit do_freq_control(long temp)
 {
-	static int limit_init;
-	struct tsens_device tsens_dev;
-	long temp = 0;
-	uint32_t max_freq = limited_max_freq;
-	int cpu = 0;
 	int ret = 0;
-	tsens_dev.sensor_num = msm_thermal_info.sensor_id;
-	ret = tsens_get_temp(&tsens_dev, &temp);
-	if (ret) {
-		pr_debug("%s: Unable to read TSENS sensor %d\n",
-				KBUILD_MODNAME, tsens_dev.sensor_num);
-		goto reschedule;
-	}
-
-	if (!limit_init) {
-		ret = msm_thermal_get_freq_table();
-		if (ret)
-			goto reschedule;
-		else
-			limit_init = 1;
-	}
-
-	do_core_control(temp);
-	do_vdd_restriction();
-	do_psm();
+	int cpu = 0;
+	uint32_t max_freq = limited_max_freq;
 
 	if (temp >= msm_thermal_info.limit_temp_degC) {
 		if (limit_idx == limit_idx_low)
-			goto reschedule;
+			return;
 
 		limit_idx -= msm_thermal_info.freq_step;
 		if (limit_idx < limit_idx_low)
@@ -787,7 +772,7 @@ static void __cpuinit check_temp(struct work_struct *work)
 	} else if (temp < msm_thermal_info.limit_temp_degC -
 		 msm_thermal_info.temp_hysteresis_degC) {
 		if (limit_idx == limit_idx_high)
-			goto reschedule;
+			return;
 
 		limit_idx += msm_thermal_info.freq_step;
 		if (limit_idx >= limit_idx_high) {
@@ -796,11 +781,14 @@ static void __cpuinit check_temp(struct work_struct *work)
 		} else
 			max_freq = table[limit_idx].frequency;
 	}
+
 	if (max_freq == limited_max_freq)
-		goto reschedule;
+		return;
 
 	/* Update new limits */
 	for_each_possible_cpu(cpu) {
+		if (!(msm_thermal_info.freq_control_mask & BIT(cpu)))
+			continue;
 		ret = update_cpu_max_freq(cpu, max_freq);
 		if (ret)
 			pr_debug(
@@ -808,6 +796,36 @@ static void __cpuinit check_temp(struct work_struct *work)
 					KBUILD_MODNAME, cpu, max_freq);
 	}
 
+}
+
+static void __cpuinit check_temp(struct work_struct *work)
+{
+	static int limit_init;
+	struct tsens_device tsens_dev;
+	long temp = 0;
+	int ret = 0;
+
+	tsens_dev.sensor_num = msm_thermal_info.sensor_id;
+	ret = tsens_get_temp(&tsens_dev, &temp);
+	if (ret) {
+		pr_debug("%s: Unable to read TSENS sensor %d\n",
+				KBUILD_MODNAME, tsens_dev.sensor_num);
+		goto reschedule;
+	}
+
+	if (!limit_init) {
+		ret = msm_thermal_get_freq_table();
+		if (ret)
+			goto reschedule;
+		else
+			limit_init = 1;
+	}
+
+	do_core_control(temp);
+	do_vdd_restriction();
+	do_psm();
+	do_freq_control(temp);
+
 reschedule:
 	if (enabled)
 		schedule_delayed_work(&check_temp_work,
@@ -1599,6 +1617,9 @@ static int __devinit msm_thermal_dev_probe(struct platform_device *pdev)
 	if (ret)
 		goto fail;
 
+	key = "qcom,freq-control-mask";
+	ret = of_property_read_u32(node, key, &data.freq_control_mask);
+
 	key = "qcom,core-limit-temp";
 	ret = of_property_read_u32(node, key, &data.core_limit_temp_degC);
 
diff --git a/include/linux/msm_thermal.h b/include/linux/msm_thermal.h
index f14cc52..2c1fa11 100644
--- a/include/linux/msm_thermal.h
+++ b/include/linux/msm_thermal.h
@@ -20,6 +20,7 @@ struct msm_thermal_data {
 	int32_t limit_temp_degC;
 	int32_t temp_hysteresis_degC;
 	uint32_t freq_step;
+	uint32_t freq_control_mask;
 	int32_t core_limit_temp_degC;
 	int32_t core_temp_hysteresis_degC;
 	uint32_t core_control_mask;
